---
tags:
  - 개발
  - 기술정리
  - 자료구조
aliases:
  - LinkedList vs ArrayList 비교
  - 자바 리스트 성능 비교
created: 2025-05-19
type: 기술정리
---

# 📘 LinkedList vs ArrayList

[[LinkedList 자료형]]와 [[ArrayList 자료형]]는 둘 다 [[List]] 인터페이스를 구현한 클래스이지만, **데이터 저장 방식과 연산 성능에서 중요한 차이점**이 존재합니다.


---

## 📌 내부 구조 차이

| 항목 | ArrayList | LinkedList |
|------|-----------|------------|
| 저장 방식 | 동적 배열 | 이중 연결 리스트 (Doubly Linked List) |
| 요소 접근 방식 | 인덱스를 통한 직접 접근 | 노드를 순차 탐색하여 접근 |
| 메모리 구조 | 연속된 메모리 공간 | 비연속적인 메모리, 노드마다 참조 포함 |

---

## ⚙️ 주요 연산 시간 복잡도

| 연산 | ArrayList | LinkedList |
|------|-----------|------------|
| 조회 (get) | O(1) | O(N) |
| 삽입/삭제 (끝에) | O(1) (가끔 O(N) 복사 발생) | O(1) |
| 삽입/삭제 (중간) | O(N) | O(N) (탐색 후 링크 수정은 빠름) |

> 💡 `LinkedList`는 삽입/삭제는 빠르지만, 중간 위치에 도달하기 위해 순차 탐색이 필요합니다.  
> `ArrayList`는 임의 접근이 빠르지만, 중간 삽입/삭제는 요소 이동이 필요합니다.

---

## 🧭 어떤 경우에 어떤 리스트를 사용할까?

| 상황 | 적합한 자료구조 | 이유 |
|------|----------------|------|
| 요소를 빈번하게 조회해야 할 때 | **ArrayList** | 인덱스로 빠르게 접근 가능 |
| 중간에 데이터를 자주 삽입/삭제할 때 | **LinkedList** | 링크만 수정하면 되므로 효율적 |
| 메모리 사용이 중요한 경우 | **ArrayList** | 노드 포인터를 저장하지 않아 오버헤드 적음 |
| 요소 개수가 자주 변하는 경우 | **둘 다 사용 가능**, 동적 크기 지원 |

---

## 📌 추가로 알아두면 좋은 점

### 🧠 LinkedList의 메모리 오버헤드

- `LinkedList`는 각 요소가 `Node` 객체로 구성되며, 각 노드는 다음 세 가지 필드를 가집니다:
  - `item` (데이터)
  - `next` (다음 노드 참조)
  - `prev` (이전 노드 참조)

- 이로 인해, **LinkedList는 ArrayList보다 메모리 오버헤드가 큽니다**.
- 데이터 양이 많고 삽입/삭제 이점이 크지 않다면 `ArrayList`를 고려하는 것이 좋습니다.

### 🔄 for 루프 사용 시 성능 차이

| 반복 방식 | ArrayList | LinkedList |
|-----------|-----------|------------|
| `for (int i = 0; i < list.size(); i++)` | ✅ 빠름 (O(1) 접근) | ❌ 느림 (O(N²)) |
| `for (E e : list)` | ✅ | ✅ |
| `Iterator` 사용 | ✅ | ✅ |

> 💡 `LinkedList`에서 `get(i)`는 매번 순차 탐색을 하므로, 인덱스 기반 루프는 **성능 저하**를 일으킬 수 있습니다.


## 🔗 함께 보면 좋은 문서

- [[ArrayList 자료형]]
- [[LinkedList 자료형]]
- [[Collection Framework]]
- [[Big O 표기법]]
