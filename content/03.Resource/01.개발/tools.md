# ë„êµ¬ í˜¸ì¶œ (Tool Calling)

_Tool calling_ (ë˜ëŠ” _function calling_)ì€ AI ì• í”Œë¦¬ì¼€ì´ì…˜ì—ì„œ ì¼ë°˜ì ìœ¼ë¡œ ì‚¬ìš©ë˜ëŠ” íŒ¨í„´ìœ¼ë¡œ, ëª¨ë¸ì´ ì¼ë ¨ì˜ API ë˜ëŠ” _ë„êµ¬_ì™€ ìƒí˜¸ì‘ìš©í•˜ì—¬ ê¸°ëŠ¥ì„ í™•ì¥í•  ìˆ˜ ìˆë„ë¡ í•©ë‹ˆë‹¤.

ë„êµ¬ëŠ” ì£¼ë¡œ ë‹¤ìŒê³¼ ê°™ì€ ìš©ë„ë¡œ ì‚¬ìš©ë©ë‹ˆë‹¤:

* ***ì •ë³´ ê²€ìƒ‰ (Information Retrieval)***  
  ì´ ë²”ì£¼ì˜ ë„êµ¬ëŠ” ì™¸ë¶€ ì†ŒìŠ¤(ì˜ˆ: ë°ì´í„°ë² ì´ìŠ¤, ì›¹ ì„œë¹„ìŠ¤, íŒŒì¼ ì‹œìŠ¤í…œ, ì›¹ ê²€ìƒ‰ ì—”ì§„ ë“±)ë¡œë¶€í„° ì •ë³´ë¥¼ ê²€ìƒ‰í•˜ëŠ” ë° ì‚¬ìš©ë©ë‹ˆë‹¤. ëª©ì ì€ ëª¨ë¸ì˜ ì§€ì‹ì„ ë³´ì™„í•˜ì—¬, ê·¸ë ‡ì§€ ì•Šìœ¼ë©´ ë‹µí•  ìˆ˜ ì—†ëŠ” ì§ˆë¬¸ì— ì‘ë‹µí•  ìˆ˜ ìˆê²Œ í•˜ëŠ” ê²ƒì…ë‹ˆë‹¤. ì´ëŸ¬í•œ ë„êµ¬ëŠ” Retrieval Augmented Generation(RAG) ì‹œë‚˜ë¦¬ì˜¤ì—ì„œ í™œìš©ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´, íŠ¹ì • ìœ„ì¹˜ì˜ í˜„ì¬ ë‚ ì”¨ë¥¼ ê°€ì ¸ì˜¤ê±°ë‚˜, ìµœì‹  ë‰´ìŠ¤ ê¸°ì‚¬ë¥¼ ê²€ìƒ‰í•˜ê±°ë‚˜, íŠ¹ì • ë ˆì½”ë“œë¥¼ ì¡°íšŒí•˜ëŠ” ì¿¼ë¦¬ë¥¼ ë°ì´í„°ë² ì´ìŠ¤ì— ì‹¤í–‰í•˜ëŠ” ë° ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

* ***í–‰ë™ ìˆ˜í–‰ (Taking Action)***  
  ì´ ë²”ì£¼ì˜ ë„êµ¬ëŠ” ì†Œí”„íŠ¸ì›¨ì–´ ì‹œìŠ¤í…œ ë‚´ì—ì„œ ì–´ë–¤ ì‘ì—…ì„ ìˆ˜í–‰í•˜ëŠ” ë° ì‚¬ìš©ë©ë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´ ì´ë©”ì¼ì„ ë³´ë‚´ê±°ë‚˜, ë°ì´í„°ë² ì´ìŠ¤ì— ìƒˆë¡œìš´ ë ˆì½”ë“œë¥¼ ìƒì„±í•˜ê±°ë‚˜, í¼ì„ ì œì¶œí•˜ê±°ë‚˜, ì›Œí¬í”Œë¡œë¥¼ íŠ¸ë¦¬ê±°í•˜ëŠ” ë“±ì˜ ì‘ì—…ì´ í•´ë‹¹ë©ë‹ˆë‹¤. ëª©ì ì€ ì‚¬ëŒì´ ì§ì ‘ ê°œì…í•˜ê±°ë‚˜ ëª…ì‹œì ì¸ í”„ë¡œê·¸ë˜ë°ì´ í•„ìš”í•œ ì‘ì—…ì„ ìë™í™”í•˜ëŠ” ê²ƒì…ë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´, ì±—ë´‡ê³¼ ìƒí˜¸ì‘ìš© ì¤‘ì¸ ê³ ê°ì˜ í•­ê³µí¸ì„ ì˜ˆì•½í•˜ê±°ë‚˜, ì›¹ í˜ì´ì§€ì—ì„œ í¼ì„ ìë™ìœ¼ë¡œ ì‘ì„±í•˜ê±°ë‚˜, ìë™í™”ëœ í…ŒìŠ¤íŠ¸(TDD)ì— ê¸°ë°˜í•˜ì—¬ Java í´ë˜ìŠ¤ë¥¼ ìƒì„±í•˜ëŠ” ì½”ë“œ ìƒì„± ì‹œë‚˜ë¦¬ì˜¤ì— ë„êµ¬ë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

_tool calling_ ì€ ì¼ë°˜ì ìœ¼ë¡œ ëª¨ë¸ì˜ ê¸°ëŠ¥ìœ¼ë¡œ ì–¸ê¸‰ë˜ì§€ë§Œ, ì‹¤ì œë¡œëŠ” í´ë¼ì´ì–¸íŠ¸ ì• í”Œë¦¬ì¼€ì´ì…˜ì´ ë„êµ¬ í˜¸ì¶œ ë¡œì§ì„ ì œê³µí•´ì•¼ í•©ë‹ˆë‹¤. ëª¨ë¸ì€ ë„êµ¬ í˜¸ì¶œì„ ìš”ì²­í•˜ê³  ì…ë ¥ ì¸ìë¥¼ ì œê³µí•  ìˆ˜ëŠ” ìˆì§€ë§Œ, ì…ë ¥ ì¸ìë¥¼ ë°”íƒ•ìœ¼ë¡œ ë„êµ¬ë¥¼ ì‹¤ì œë¡œ ì‹¤í–‰í•˜ê³  ê²°ê³¼ë¥¼ ë°˜í™˜í•˜ëŠ” ì±…ì„ì€ ì• í”Œë¦¬ì¼€ì´ì…˜ì— ìˆìŠµë‹ˆë‹¤. ëª¨ë¸ì€ ë„êµ¬ë¡œ ì œê³µë˜ëŠ” ì–´ë–¤ APIì—ë„ ì§ì ‘ ì ‘ê·¼í•  ìˆ˜ ì—†ìœ¼ë©°, ì´ëŠ” ë³´ì•ˆìƒ ë§¤ìš° ì¤‘ìš”í•œ ê³ ë ¤ ì‚¬í•­ì…ë‹ˆë‹¤.

Spring AIëŠ” ë„êµ¬ë¥¼ ì •ì˜í•˜ê³ , ëª¨ë¸ì˜ ë„êµ¬ í˜¸ì¶œ ìš”ì²­ì„ ì²˜ë¦¬í•˜ë©°, ë„êµ¬ í˜¸ì¶œì„ ì‹¤í–‰í•  ìˆ˜ ìˆë„ë¡ í¸ë¦¬í•œ APIë¥¼ ì œê³µí•©ë‹ˆë‹¤. ë‹¤ìŒ ì„¹ì…˜ì—ì„œëŠ” Spring AIì˜ ë„êµ¬ í˜¸ì¶œ ê¸°ëŠ¥ì— ëŒ€í•œ ê°œìš”ë¥¼ ì„¤ëª…í•©ë‹ˆë‹¤.

**ğŸ“Œ ì°¸ê³ **
ì–´ë–¤ AI ëª¨ë¸ì´ ë„êµ¬ í˜¸ì¶œ(tool calling)ì„ ì§€ì›í•˜ëŠ”ì§€ í™•ì¸í•˜ë ¤ë©´ [Chat Model Comparisons](api/chat/comparison.adoc)ë¥¼ ì°¸ê³ í•˜ì„¸ìš”.

**ğŸ’¡ íŒ**
ë” ì´ìƒ ì‚¬ìš©ë˜ì§€ ì•ŠëŠ” [FunctionCallbackì—ì„œ ToolCallback APIë¡œ ë§ˆì´ê·¸ë ˆì´ì…˜](api/tools-migration.adoc)í•˜ëŠ” ê°€ì´ë“œë¥¼ ë”°ë¼ ì§„í–‰í•˜ì„¸ìš”.

## ë¹ ë¥¸ ì‹œì‘ (Quick Start)

ì´ì œ Spring AIì—ì„œ ë„êµ¬ í˜¸ì¶œì„ ì‚¬ìš©í•˜ëŠ” ë°©ë²•ì„ ì•Œì•„ë³´ê² ìŠµë‹ˆë‹¤. ì •ë³´ ê²€ìƒ‰ìš© ë„êµ¬ í•˜ë‚˜ì™€ í–‰ë™ ìˆ˜í–‰ìš© ë„êµ¬ í•˜ë‚˜, ì´ë ‡ê²Œ ë‘ ê°€ì§€ ê°„ë‹¨í•œ ë„êµ¬ë¥¼ êµ¬í˜„í•  ê²ƒì…ë‹ˆë‹¤.  
ì •ë³´ ê²€ìƒ‰ ë„êµ¬ëŠ” ì‚¬ìš©ìì˜ ì‹œê°„ëŒ€ì— ë§ëŠ” í˜„ì¬ ë‚ ì§œì™€ ì‹œê°„ì„ ê°€ì ¸ì˜¤ëŠ” ë° ì‚¬ìš©ë©ë‹ˆë‹¤.  
í–‰ë™ ìˆ˜í–‰ ë„êµ¬ëŠ” ì§€ì •ëœ ì‹œê°„ì— ì•ŒëŒì„ ì„¤ì •í•˜ëŠ” ë° ì‚¬ìš©ë©ë‹ˆë‹¤.

### ì •ë³´ ê²€ìƒ‰ (Information Retrieval)

AI ëª¨ë¸ì€ ì‹¤ì‹œê°„ ì •ë³´ì— ì ‘ê·¼í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. í˜„ì¬ ë‚ ì§œë‚˜ ë‚ ì”¨ ì˜ˆë³´ ë“±ê³¼ ê°™ì€ ì‹¤ì‹œê°„ ì •ë³´ë¥¼ ì „ì œë¡œ í•œ ì§ˆë¬¸ì—ëŠ” ëª¨ë¸ì´ ìŠ¤ìŠ¤ë¡œ ì‘ë‹µí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.  
í•˜ì§€ë§Œ ìš°ë¦¬ëŠ” ì´ëŸ¬í•œ ì •ë³´ë¥¼ ê²€ìƒ‰í•˜ëŠ” ë„êµ¬ë¥¼ ì œê³µí•˜ê³ , ëª¨ë¸ì´ ì‹¤ì‹œê°„ ì •ë³´ê°€ í•„ìš”í•  ë•Œ ì´ ë„êµ¬ë¥¼ í˜¸ì¶œí•  ìˆ˜ ìˆë„ë¡ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ì‚¬ìš©ìì˜ ì‹œê°„ëŒ€ì— ë§ì¶° í˜„ì¬ ë‚ ì§œì™€ ì‹œê°„ì„ ê°€ì ¸ì˜¤ëŠ” ë„êµ¬ë¥¼ `DateTimeTools` í´ë˜ìŠ¤ì—ì„œ êµ¬í˜„í•´ë³´ê² ìŠµë‹ˆë‹¤.  
ì´ ë„êµ¬ëŠ” ì¸ìë¥¼ ë°›ì§€ ì•ŠìŠµë‹ˆë‹¤.  
Spring Frameworkì˜ `LocaleContextHolder`ë¥¼ ì‚¬ìš©í•˜ë©´ ì‚¬ìš©ìì˜ ì‹œê°„ëŒ€ë¥¼ ê°€ì ¸ì˜¬ ìˆ˜ ìˆìŠµë‹ˆë‹¤.  
ë„êµ¬ëŠ” `@Tool` ì• ë…¸í…Œì´ì…˜ì´ ì§€ì •ëœ ë©”ì„œë“œë¡œ ì •ì˜ë©ë‹ˆë‹¤.  
ëª¨ë¸ì´ ì–¸ì œ, ì™œ ì´ ë„êµ¬ë¥¼ í˜¸ì¶œí•´ì•¼ í•˜ëŠ”ì§€ ì´í•´í•  ìˆ˜ ìˆë„ë¡, ë„êµ¬ê°€ ìˆ˜í–‰í•˜ëŠ” ì‘ì—…ì— ëŒ€í•œ **ìƒì„¸í•œ ì„¤ëª…**ë„ í•¨ê»˜ ì œê³µí•©ë‹ˆë‹¤.

```java
import java.time.LocalDateTime;
import org.springframework.ai.tool.annotation.Tool;
import org.springframework.context.i18n.LocaleContextHolder;

class DateTimeTools {

    @Tool(description = "Get the current date and time in the user's timezone")
    String getCurrentDateTime() {
        return LocalDateTime.now().atZone(LocaleContextHolder.getTimeZone().toZoneId()).toString();
    }

}
```

ì´ì œ ëª¨ë¸ì´ ì´ ë„êµ¬ë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆë„ë¡ ë§Œë“¤ì–´ ë³´ê² ìŠµë‹ˆë‹¤.  
ì´ë²ˆ ì˜ˆì œì—ì„œëŠ” `ChatClient`ë¥¼ ì‚¬ìš©í•˜ì—¬ ëª¨ë¸ê³¼ ìƒí˜¸ì‘ìš©í•  ê²ƒì…ë‹ˆë‹¤.  
`tools()` ë©”ì„œë“œë¥¼ í†µí•´ `DateTimeTools` ì¸ìŠ¤í„´ìŠ¤ë¥¼ ì „ë‹¬í•˜ì—¬ ë„êµ¬ë¥¼ ëª¨ë¸ì— ì œê³µí•˜ê²Œ ë©ë‹ˆë‹¤.  
ëª¨ë¸ì´ í˜„ì¬ ë‚ ì§œì™€ ì‹œê°„ì´ í•„ìš”í•  ë•Œ, í•´ë‹¹ ë„êµ¬ë¥¼ í˜¸ì¶œí•´ë‹¬ë¼ê³  ìš”ì²­í•˜ê²Œ ë©ë‹ˆë‹¤.

ë‚´ë¶€ì ìœ¼ë¡œëŠ” `ChatClient`ê°€ ë„êµ¬ë¥¼ í˜¸ì¶œí•˜ê³ , ê·¸ ê²°ê³¼ë¥¼ ëª¨ë¸ì— ë°˜í™˜í•©ë‹ˆë‹¤.  
ëª¨ë¸ì€ ë„êµ¬ í˜¸ì¶œ ê²°ê³¼ë¥¼ ì‚¬ìš©í•˜ì—¬ ì›ë˜ ì§ˆë¬¸ì— ëŒ€í•œ ìµœì¢… ì‘ë‹µì„ ìƒì„±í•˜ê²Œ ë©ë‹ˆë‹¤.

```java
ChatModel chatModel = ...

String response = ChatClient.create(chatModel)
        .prompt("What day is tomorrow?")
        .tools(new DateTimeTools())
        .call()
        .content();

System.out.println(response);
```

ì¶œë ¥ ê²°ê³¼ëŠ” ë‹¤ìŒê³¼ ë¹„ìŠ·í•˜ê²Œ ë‚˜íƒ€ë‚©ë‹ˆë‹¤:

```
Tomorrow is 2015-10-21.
```

ê°™ì€ ì§ˆë¬¸ì„ ë‹¤ì‹œ ì‹œë„í•´ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.  ì´ë²ˆì—ëŠ” ëª¨ë¸ì— ë„êµ¬ë¥¼ ì œê³µí•˜ì§€ ë§ˆì„¸ìš”.  

ì¶œë ¥ ê²°ê³¼ëŠ” ë‹¤ìŒê³¼ ë¹„ìŠ·í•˜ê²Œ ë‚˜íƒ€ë‚  ê²ƒì…ë‹ˆë‹¤:

```
I am an AI and do not have access to real-time information. Please provide the current date so I can accurately determine what day tomorrow will be.
```

ë„êµ¬ê°€ ì—†ìœ¼ë©´ ëª¨ë¸ì€ í˜„ì¬ ë‚ ì§œì™€ ì‹œê°„ì„ íŒë‹¨í•  ìˆ˜ ìˆëŠ” ëŠ¥ë ¥ì´ ì—†ê¸° ë•Œë¬¸ì— ì§ˆë¬¸ì— ì–´ë–»ê²Œ ë‹µí•´ì•¼ í• ì§€ ëª¨ë¦…ë‹ˆë‹¤.

### í–‰ë™ ìˆ˜í–‰ (Taking Actions)

AI ëª¨ë¸ì€ íŠ¹ì • ëª©í‘œë¥¼ ë‹¬ì„±í•˜ê¸° ìœ„í•œ ê³„íšì„ ìƒì„±í•˜ëŠ” ë° ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.  
ì˜ˆë¥¼ ë“¤ì–´, ëª¨ë¸ì€ ë´ë§ˆí¬ ì—¬í–‰ ì˜ˆì•½ ê³„íšì„ ìƒì„±í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.  
í•˜ì§€ë§Œ ëª¨ë¸ì€ ê·¸ ê³„íšì„ ì‹¤ì œë¡œ **ìˆ˜í–‰**í•  ìˆ˜ ìˆëŠ” ëŠ¥ë ¥ì€ ì—†ìŠµë‹ˆë‹¤.  
ì´ëŸ´ ë•Œ **ë„êµ¬**ê°€ í•„ìš”í•œë°, ë„êµ¬ëŠ” ëª¨ë¸ì´ ìƒì„±í•œ ê³„íšì„ ì‹¤í–‰í•˜ëŠ” ë° ì‚¬ìš©ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ì•ì„  ì˜ˆì œì—ì„œëŠ” í˜„ì¬ ë‚ ì§œì™€ ì‹œê°„ì„ í™•ì¸í•˜ëŠ” ë„êµ¬ë¥¼ ì‚¬ìš©í–ˆìŠµë‹ˆë‹¤.  
ì´ë²ˆ ì˜ˆì œì—ì„œëŠ” íŠ¹ì • ì‹œê°„ì— ì•ŒëŒì„ ì„¤ì •í•˜ëŠ” ë‘ ë²ˆì§¸ ë„êµ¬ë¥¼ ì •ì˜í•˜ê² ìŠµë‹ˆë‹¤.  
ëª©í‘œëŠ” **í˜„ì¬ ì‹œê°„ìœ¼ë¡œë¶€í„° 10ë¶„ ë’¤ì— ì•ŒëŒì„ ì„¤ì •**í•˜ëŠ” ê²ƒì´ë¯€ë¡œ, ì´ ì‘ì—…ì„ ìˆ˜í–‰í•˜ë ¤ë©´ ë‘ ë„êµ¬ ëª¨ë‘ ëª¨ë¸ì— ì œê³µí•´ì•¼ í•©ë‹ˆë‹¤.

ìƒˆë¡œìš´ ë„êµ¬ëŠ” ì´ì „ê³¼ ë™ì¼í•œ `DateTimeTools` í´ë˜ìŠ¤ì— ì¶”ê°€í•  ê²ƒì…ë‹ˆë‹¤.  
ì´ ë„êµ¬ëŠ” **ISO-8601 í˜•ì‹ì˜ ì‹œê°„**ì„ ë‹¨ì¼ ë§¤ê°œë³€ìˆ˜ë¡œ ë°›ìŠµë‹ˆë‹¤.  
ê·¸ í›„ í•´ë‹¹ ì‹œê°„ì— ì•ŒëŒì´ ì„¤ì •ë˜ì—ˆìŒì„ ë‚˜íƒ€ë‚´ëŠ” ë©”ì‹œì§€ë¥¼ ì½˜ì†”ì— ì¶œë ¥í•©ë‹ˆë‹¤.  
ì´ì „ê³¼ ë§ˆì°¬ê°€ì§€ë¡œ ë„êµ¬ëŠ” `@Tool` ì• ë…¸í…Œì´ì…˜ì´ ì§€ì •ëœ ë©”ì„œë“œë¡œ ì •ì˜ë˜ë©°,  
ëª¨ë¸ì´ ì´ ë„êµ¬ë¥¼ **ì–¸ì œ**, **ì–´ë–»ê²Œ** ì‚¬ìš©í• ì§€ ì´í•´í•  ìˆ˜ ìˆë„ë¡ **ìƒì„¸í•œ ì„¤ëª…**ë„ í•¨ê»˜ ì œê³µí•©ë‹ˆë‹¤.


```java
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import org.springframework.ai.tool.annotation.Tool;
import org.springframework.context.i18n.LocaleContextHolder;

class DateTimeTools {

    @Tool(description = "Get the current date and time in the user's timezone")
    String getCurrentDateTime() {
        return LocalDateTime.now().atZone(LocaleContextHolder.getTimeZone().toZoneId()).toString();
    }

    @Tool(description = "Set a user alarm for the given time, provided in ISO-8601 format")
    void setAlarm(String time) {
        LocalDateTime alarmTime = LocalDateTime.parse(time, DateTimeFormatter.ISO_DATE_TIME);
        System.out.println("Alarm set for " + alarmTime);
    }

}
```

ì´ì œ ë‘ ê°€ì§€ ë„êµ¬ë¥¼ ëª¨ë‘ ëª¨ë¸ì—ì„œ ì‚¬ìš©í•  ìˆ˜ ìˆë„ë¡ í•´ë³´ê² ìŠµë‹ˆë‹¤.  
`ChatClient`ë¥¼ ì‚¬ìš©í•˜ì—¬ ëª¨ë¸ê³¼ ìƒí˜¸ì‘ìš©í•  ê²ƒì…ë‹ˆë‹¤.  
`tools()` ë©”ì„œë“œë¥¼ í†µí•´ `DateTimeTools` ì¸ìŠ¤í„´ìŠ¤ë¥¼ ì „ë‹¬í•˜ì—¬ ë„êµ¬ë“¤ì„ ëª¨ë¸ì— ì œê³µí•©ë‹ˆë‹¤.

â€œì§€ê¸ˆìœ¼ë¡œë¶€í„° 10ë¶„ ë’¤ì— ì•ŒëŒì„ ì„¤ì •í•´ ì£¼ì„¸ìš”â€ë¼ê³  ìš”ì²­í•˜ë©´,  
ëª¨ë¸ì€ ë¨¼ì € í˜„ì¬ ë‚ ì§œì™€ ì‹œê°„ì„ ì•Œì•„ì•¼ í•©ë‹ˆë‹¤.  
ê·¸ë‹¤ìŒ í˜„ì¬ ì‹œê°„ì„ ê¸°ë°˜ìœ¼ë¡œ ì•ŒëŒ ì‹œê°„ì„ ê³„ì‚°í•˜ê³ ,  
ë§ˆì§€ë§‰ìœ¼ë¡œ ì•ŒëŒ ë„êµ¬ë¥¼ ì‚¬ìš©í•˜ì—¬ ì•ŒëŒì„ ì„¤ì •í•˜ê²Œ ë©ë‹ˆë‹¤.

ë‚´ë¶€ì ìœ¼ë¡œ `ChatClient`ëŠ” ëª¨ë¸ì´ ìš”ì²­í•œ ë„êµ¬ í˜¸ì¶œì„ ì²˜ë¦¬í•˜ê³ ,  
ë„êµ¬ ì‹¤í–‰ ê²°ê³¼ë¥¼ ëª¨ë¸ì— ë‹¤ì‹œ ì „ë‹¬í•©ë‹ˆë‹¤.  
ì´ ê²°ê³¼ë¥¼ ë°”íƒ•ìœ¼ë¡œ ëª¨ë¸ì€ ìµœì¢… ì‘ë‹µì„ ìƒì„±í•˜ê²Œ ë©ë‹ˆë‹¤.


```java
ChatModel chatModel = ...

String response = ChatClient.create(chatModel)
        .prompt("Can you set an alarm 10 minutes from now?")
        .tools(new DateTimeTools())
        .call()
        .content();

System.out.println(response);
```

ì• í”Œë¦¬ì¼€ì´ì…˜ ë¡œê·¸ë¥¼ í†µí•´ ì•ŒëŒì´ ì˜¬ë°”ë¥¸ ì‹œê°„ì— ì„¤ì •ë˜ì—ˆëŠ”ì§€ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

## ê°œìš” (Overview)

Spring AIëŠ” ë„êµ¬ í˜¸ì¶œ(tool calling)ì„ ìœ„í•œ ìœ ì—°í•œ ì¶”ìƒí™” ê³„ì¸µì„ ì œê³µí•˜ì—¬, ë„êµ¬ë¥¼ ì •ì˜í•˜ê³ , í•´ì„í•˜ê³ , ì‹¤í–‰í•˜ëŠ” ì‘ì—…ì„ ì¼ê´€ëœ ë°©ì‹ìœ¼ë¡œ ìˆ˜í–‰í•  ìˆ˜ ìˆë„ë¡ ì§€ì›í•©ë‹ˆë‹¤.  
ì´ ì„¹ì…˜ì—ì„œëŠ” Spring AIì˜ ë„êµ¬ í˜¸ì¶œ ê¸°ëŠ¥ê³¼ ê´€ë ¨ëœ ì£¼ìš” ê°œë… ë° êµ¬ì„± ìš”ì†Œì— ëŒ€í•´ ê°œìš”ë¥¼ ì œê³µí•©ë‹ˆë‹¤.

![image.png](https://file-api.ksq9511.synology.me:5353/obsidian-files/image/20250520181500_image.png)

1. ëª¨ë¸ì´ ë„êµ¬ë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆë„ë¡ í•˜ë ¤ë©´, ì±„íŒ… ìš”ì²­(chat request)ì— í•´ë‹¹ ë„êµ¬ì˜ ì •ì˜ë¥¼ í¬í•¨ì‹œí‚µë‹ˆë‹¤. ê° ë„êµ¬ ì •ì˜ëŠ” ì´ë¦„(name), ì„¤ëª…(description), ì…ë ¥ ë§¤ê°œë³€ìˆ˜ì˜ ìŠ¤í‚¤ë§ˆ(schema)ë¡œ êµ¬ì„±ë©ë‹ˆë‹¤.
2. ëª¨ë¸ì´ ë„êµ¬ë¥¼ í˜¸ì¶œí•˜ê¸°ë¡œ ê²°ì •í•˜ë©´, ì •ì˜ëœ ìŠ¤í‚¤ë§ˆë¥¼ ê¸°ë°˜ìœ¼ë¡œ ë„êµ¬ ì´ë¦„ê³¼ ì…ë ¥ ë§¤ê°œë³€ìˆ˜ê°€ í¬í•¨ëœ ì‘ë‹µì„ ì „ì†¡í•©ë‹ˆë‹¤.
3. ì• í”Œë¦¬ì¼€ì´ì…˜ì€ ë„êµ¬ ì´ë¦„ì„ ì´ìš©í•´ ì ì ˆí•œ ë„êµ¬ë¥¼ ì‹ë³„í•˜ê³ , ì œê³µëœ ì…ë ¥ ë§¤ê°œë³€ìˆ˜ë¥¼ ì‚¬ìš©í•˜ì—¬ ì‹¤í–‰í•  ì±…ì„ì´ ìˆìŠµë‹ˆë‹¤.
4. ë„êµ¬ í˜¸ì¶œ ê²°ê³¼ëŠ” ì• í”Œë¦¬ì¼€ì´ì…˜ì—ì„œ ì²˜ë¦¬ë©ë‹ˆë‹¤.
5. ì• í”Œë¦¬ì¼€ì´ì…˜ì€ ë„êµ¬ í˜¸ì¶œ ê²°ê³¼ë¥¼ ëª¨ë¸ì— ë‹¤ì‹œ ì „ë‹¬í•©ë‹ˆë‹¤.
6. ëª¨ë¸ì€ ë„êµ¬ í˜¸ì¶œ ê²°ê³¼ë¥¼ ì¶”ê°€ì ì¸ ë¬¸ë§¥ìœ¼ë¡œ ì‚¬ìš©í•˜ì—¬ ìµœì¢… ì‘ë‹µì„ ìƒì„±í•©ë‹ˆë‹¤.

ë„êµ¬(tools)ëŠ” ë„êµ¬ í˜¸ì¶œ ê¸°ëŠ¥ì˜ í•µì‹¬ ìš”ì†Œì´ë©°, `ToolCallback` ì¸í„°í˜ì´ìŠ¤ë¥¼ í†µí•´ ëª¨ë¸ë§ë©ë‹ˆë‹¤.  
Spring AIëŠ” ë©”ì„œë“œ ë° í•¨ìˆ˜ì—ì„œ `ToolCallback`ì„ ì§€ì •í•  ìˆ˜ ìˆëŠ” ë‚´ì¥ ê¸°ëŠ¥ì„ ì œê³µí•˜ì§€ë§Œ,  
ë” ë§ì€ ì‚¬ìš© ì‚¬ë¡€ë¥¼ ì§€ì›í•˜ê¸° ìœ„í•´ ì‚¬ìš©ìê°€ ì§ì ‘ `ToolCallback` êµ¬í˜„ì²´ë¥¼ ì •ì˜í•  ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤.

`ChatModel` êµ¬í˜„ì²´ëŠ” ë„êµ¬ í˜¸ì¶œ ìš”ì²­ì„ í•´ë‹¹í•˜ëŠ” `ToolCallback` êµ¬í˜„ì²´ì— ìë™ìœ¼ë¡œ ì „ë‹¬í•˜ê³ ,  
ë„êµ¬ í˜¸ì¶œ ê²°ê³¼ë¥¼ ë‹¤ì‹œ ëª¨ë¸ì— ì „ë‹¬í•˜ì—¬ ìµœì¢… ì‘ë‹µ ìƒì„±ì„ ë•ìŠµë‹ˆë‹¤.  
ì´ ì‘ì—…ì€ ë„êµ¬ ì‹¤í–‰ ìƒëª… ì£¼ê¸°ë¥¼ ê´€ë¦¬í•˜ëŠ” `ToolCallingManager` ì¸í„°í˜ì´ìŠ¤ë¥¼ í†µí•´ ìˆ˜í–‰ë©ë‹ˆë‹¤.

`ChatClient`ì™€ `ChatModel` ëª¨ë‘ ëª¨ë¸ì´ ì‚¬ìš©í•  ìˆ˜ ìˆë„ë¡ ë„êµ¬ë¥¼ ì œê³µí•˜ê¸° ìœ„í•´  
`ToolCallback` ê°ì²´ì˜ ëª©ë¡ê³¼ ë„êµ¬ë¥¼ ì‹¤í–‰í•  `ToolCallingManager`ë¥¼ ì¸ìë¡œ ë°›ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

`ToolCallback` ê°ì²´ë“¤ì„ ì§ì ‘ ì „ë‹¬í•˜ëŠ” ê²ƒ ì™¸ì—ë„,  
ë„êµ¬ ì´ë¦„ ëª©ë¡ì„ ì „ë‹¬í•˜ì—¬ `ToolCallbackResolver` ì¸í„°í˜ì´ìŠ¤ë¥¼ í†µí•´ ë™ì ìœ¼ë¡œ ë„êµ¬ë¥¼ í•´ì„í•  ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤.

ë‹¤ìŒ ì„¹ì…˜ì—ì„œëŠ” ì´ëŸ¬í•œ ê°œë…ê³¼ APIë“¤ì— ëŒ€í•´ ë” ìì„¸íˆ ì„¤ëª…í•˜ê³ ,  
ë‹¤ì–‘í•œ ì‚¬ìš© ì‚¬ë¡€ë¥¼ ì§€ì›í•˜ê¸° ìœ„í•œ ì‚¬ìš©ì ì •ì˜ ë° í™•ì¥ ë°©ë²•ë„ í•¨ê»˜ ì†Œê°œí•©ë‹ˆë‹¤.

## ë©”ì„œë“œë¥¼ ë„êµ¬ë¡œ ì‚¬ìš©í•˜ê¸° (Methods as Tools)

Spring AIëŠ” ë©”ì„œë“œë¥¼ í†µí•´ ë„êµ¬(`ToolCallback`)ë¥¼ ì§€ì •í•  ìˆ˜ ìˆëŠ” ë‘ ê°€ì§€ ê¸°ë³¸ ë°©ì‹ì„ ì œê³µí•©ë‹ˆë‹¤:

* ì„ ì–¸ì ìœ¼ë¡œ `@Tool` ì• ë…¸í…Œì´ì…˜ì„ ì‚¬ìš©í•˜ëŠ” ë°©ë²•
* í”„ë¡œê·¸ë˜ë°ì ìœ¼ë¡œ `MethodToolCallback`ì´ë¼ëŠ” ì €ìˆ˜ì¤€ êµ¬í˜„ì²´ë¥¼ ì‚¬ìš©í•˜ëŠ” ë°©ë²•


### Declarative Specification: `@Tool`

ë©”ì„œë“œì— `@Tool` ì• ë…¸í…Œì´ì…˜ì„ ì¶”ê°€í•˜ë©´ í•´ë‹¹ ë©”ì„œë“œë¥¼ ë„êµ¬ë¡œ ë³€í™˜í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.


```java
class DateTimeTools {

    @Tool(description = "Get the current date and time in the user's timezone")
    String getCurrentDateTime() {
        return LocalDateTime.now().atZone(LocaleContextHolder.getTimeZone().toZoneId()).toString();
    }

}
```

`@Tool` ì• ë…¸í…Œì´ì…˜ì„ ì‚¬ìš©í•˜ë©´ ë„êµ¬ì— ëŒ€í•œ í•µì‹¬ ì •ë³´ë¥¼ ì œê³µí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:

* `name`: ë„êµ¬ì˜ ì´ë¦„ì…ë‹ˆë‹¤. ì§€ì •í•˜ì§€ ì•Šìœ¼ë©´ ë©”ì„œë“œ ì´ë¦„ì´ ì‚¬ìš©ë©ë‹ˆë‹¤.  
  AI ëª¨ë¸ì€ ì´ ì´ë¦„ì„ ì‚¬ìš©í•˜ì—¬ ë„êµ¬ë¥¼ í˜¸ì¶œí•˜ë¯€ë¡œ, ë™ì¼í•œ í´ë˜ìŠ¤ ë‚´ì— ê°™ì€ ì´ë¦„ì˜ ë„êµ¬ê°€ ë‘ ê°œ ì´ìƒ ì¡´ì¬í•´ì„œëŠ” ì•ˆ ë©ë‹ˆë‹¤.  
  íŠ¹ì • ì±„íŒ… ìš”ì²­ì—ì„œ ëª¨ë¸ì´ ì ‘ê·¼í•  ìˆ˜ ìˆëŠ” ëª¨ë“  ë„êµ¬ë“¤ ê°„ì— ì´ë¦„ì€ ê³ ìœ í•´ì•¼ í•©ë‹ˆë‹¤.

* `description`: ë„êµ¬ì— ëŒ€í•œ ì„¤ëª…ìœ¼ë¡œ, ëª¨ë¸ì´ ë„êµ¬ë¥¼ ì–¸ì œ, ì–´ë–»ê²Œ í˜¸ì¶œí•´ì•¼ í•˜ëŠ”ì§€ë¥¼ ì´í•´í•˜ëŠ” ë° ì‚¬ìš©ë©ë‹ˆë‹¤.  
  ì§€ì •í•˜ì§€ ì•Šìœ¼ë©´ ë©”ì„œë“œ ì´ë¦„ì´ ì„¤ëª…ìœ¼ë¡œ ì‚¬ìš©ë©ë‹ˆë‹¤.  
  í•˜ì§€ë§Œ **ëª¨ë¸ì´ ë„êµ¬ì˜ ëª©ì ê³¼ ì‚¬ìš©ë²•ì„ ì´í•´í•˜ëŠ” ë° ìˆì–´ ì„¤ëª…ì€ ë§¤ìš° ì¤‘ìš”**í•˜ë¯€ë¡œ,  
  ê°€ëŠ¥í•œ í•œ ìƒì„¸í•œ ì„¤ëª…ì„ ì œê³µí•˜ëŠ” ê²ƒì´ ê°•ë ¥íˆ ê¶Œì¥ë©ë‹ˆë‹¤.  
  ì„¤ëª…ì´ ì¶©ë¶„í•˜ì§€ ì•Šìœ¼ë©´ ëª¨ë¸ì´ ë„êµ¬ë¥¼ **í•„ìš”í•  ë•Œ ì‚¬ìš©í•˜ì§€ ì•Šê±°ë‚˜**, **ì˜ëª» ì‚¬ìš©í•˜ëŠ”** ë¬¸ì œê°€ ë°œìƒí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

* `returnDirect`: ë„êµ¬ ì‹¤í–‰ ê²°ê³¼ë¥¼ í´ë¼ì´ì–¸íŠ¸ì— ì§ì ‘ ë°˜í™˜í• ì§€, ì•„ë‹ˆë©´ ëª¨ë¸ì— ë‹¤ì‹œ ì „ë‹¬í• ì§€ë¥¼ ì§€ì •í•©ë‹ˆë‹¤.  
  ìì„¸í•œ ë‚´ìš©ì€ [Return Direct](#return-direct) í•­ëª©ì„ ì°¸ì¡°í•˜ì„¸ìš”.

* `resultConverter`: ë„êµ¬ í˜¸ì¶œ ê²°ê³¼ë¥¼ `String ê°ì²´`ë¡œ ë³€í™˜í•˜ì—¬ AI ëª¨ë¸ì— ë‹¤ì‹œ ì „ë‹¬í•˜ê¸° ìœ„í•œ  
  `ToolCallResultConverter` êµ¬í˜„ì²´ì…ë‹ˆë‹¤.  
  ìì„¸í•œ ë‚´ìš©ì€ [Result Conversion](#result-conversion) í•­ëª©ì„ ì°¸ì¡°í•˜ì„¸ìš”.

ë©”ì„œë“œëŠ” `static`ì´ê±°ë‚˜ ì¸ìŠ¤í„´ìŠ¤ ë©”ì„œë“œì¼ ìˆ˜ ìˆìœ¼ë©°, ì ‘ê·¼ ì œì–´ìë„ `public`, `protected`, `package-private`, `private` ëª¨ë‘ ê°€ëŠ¥í•©ë‹ˆë‹¤.  
ì´ ë©”ì„œë“œë¥¼ í¬í•¨í•˜ëŠ” í´ë˜ìŠ¤ëŠ” ìµœìƒìœ„ í´ë˜ìŠ¤ì´ê±°ë‚˜ ì¤‘ì²© í´ë˜ìŠ¤ì¼ ìˆ˜ ìˆìœ¼ë©°,  
ì¸ìŠ¤í„´ìŠ¤í™”ê°€ ê°€ëŠ¥í•œ ë²”ìœ„ ë‚´ì—ì„œ ì ‘ê·¼ ê°€ëŠ¥í•˜ë©´ ì–´ë–¤ ì ‘ê·¼ ìˆ˜ì¤€ë„ ê´œì°®ìŠµë‹ˆë‹¤.

**ğŸ“Œ ì°¸ê³ **  
Spring AIëŠ” í•´ë‹¹ ë©”ì„œë“œë¥¼ í¬í•¨í•˜ëŠ” í´ë˜ìŠ¤ê°€ Spring Bean(`@Component` ë“±)ì¼ ê²½ìš°,  
`@Tool` ì• ë…¸í…Œì´ì…˜ì´ ì ìš©ëœ ë©”ì„œë“œì— ëŒ€í•´ AOT ì»´íŒŒì¼ì„ ê¸°ë³¸ì ìœ¼ë¡œ ì§€ì›í•©ë‹ˆë‹¤.  
ê·¸ë ‡ì§€ ì•Šì€ ê²½ìš°, GraalVM ì»´íŒŒì¼ëŸ¬ì— í•„ìš”í•œ ì„¤ì •ì„ ë³„ë„ë¡œ ì œê³µí•´ì•¼ í•©ë‹ˆë‹¤.  
ì˜ˆë¥¼ ë“¤ì–´, í´ë˜ìŠ¤ì— `@RegisterReflection(memberCategories = MemberCategory.INVOKE_DECLARED_METHODS)`ë¥¼ ì§€ì •í•˜ëŠ” ë°©ì‹ì´ ìˆìŠµë‹ˆë‹¤.

í•´ë‹¹ ë©”ì„œë“œëŠ” ëŒ€ë¶€ë¶„ì˜ íƒ€ì…(ê¸°ë³¸í˜•, POJO, enum, List, ë°°ì—´, Map ë“±)ì„ í¬í•¨í•˜ì—¬  
**ì„ì˜ ê°œìˆ˜ì˜ ì¸ì**(ë˜ëŠ” ì¸ìê°€ ì—†ëŠ” ê²½ìš°ë„ ê°€ëŠ¥)ë¥¼ ê°€ì§ˆ ìˆ˜ ìˆìŠµë‹ˆë‹¤.  
ë°˜í™˜ê°’ ë˜í•œ ëŒ€ë¶€ë¶„ì˜ íƒ€ì…ì´ ê°€ëŠ¥í•˜ë©° `void`ë„ í—ˆìš©ë©ë‹ˆë‹¤.  
ë‹¨, ë©”ì„œë“œê°€ ê°’ì„ ë°˜í™˜í•˜ëŠ” ê²½ìš°, í•´ë‹¹ ë°˜í™˜ íƒ€ì…ì€ **ì§ë ¬í™” ê°€ëŠ¥í•œ íƒ€ì…**ì´ì–´ì•¼ í•˜ë©°,  
ëª¨ë¸ë¡œ ë‹¤ì‹œ ì „ì†¡ë˜ê¸° ìœ„í•´ ì§ë ¬í™” ê³¼ì •ì´ ìˆ˜í–‰ë©ë‹ˆë‹¤.

**ğŸ“Œ ì°¸ê³ **  
ì¼ë¶€ íƒ€ì…ì€ ì§€ì›ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ìì„¸í•œ ë‚´ìš©ì€ [Method Tool Limitations](#method-tool-limitations)ë¥¼ ì°¸ê³ í•˜ì„¸ìš”.

Spring AIëŠ” `@Tool` ì• ë…¸í…Œì´ì…˜ì´ ì ìš©ëœ ë©”ì„œë“œì˜ ì…ë ¥ ë§¤ê°œë³€ìˆ˜ì— ëŒ€í•´  
**ìë™ìœ¼ë¡œ JSON ìŠ¤í‚¤ë§ˆ**ë¥¼ ìƒì„±í•©ë‹ˆë‹¤.  
ì´ ìŠ¤í‚¤ë§ˆëŠ” ëª¨ë¸ì´ ë„êµ¬ë¥¼ ì–´ë–»ê²Œ í˜¸ì¶œí•˜ê³  ìš”ì²­ì„ êµ¬ì„±í•´ì•¼ í•˜ëŠ”ì§€ë¥¼ ì´í•´í•˜ëŠ” ë° ì‚¬ìš©ë©ë‹ˆë‹¤.

ë˜í•œ `@ToolParam` ì• ë…¸í…Œì´ì…˜ì„ ì‚¬ìš©í•˜ë©´,  
ì…ë ¥ ë§¤ê°œë³€ìˆ˜ì— ëŒ€í•œ ì„¤ëª…ì´ë‚˜ í•„ìˆ˜ ì—¬ë¶€ì™€ ê°™ì€ ì¶”ê°€ ì •ë³´ë¥¼ ì§€ì •í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.  
ê¸°ë³¸ì ìœ¼ë¡œ **ëª¨ë“  ì…ë ¥ ë§¤ê°œë³€ìˆ˜ëŠ” í•„ìˆ˜(required)** ë¡œ ê°„ì£¼ë©ë‹ˆë‹¤.


```java
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import org.springframework.ai.tool.annotation.Tool;
import org.springframework.ai.tool.annotation.ToolParam;

class DateTimeTools {

    @Tool(description = "Set a user alarm for the given time")
    void setAlarm(@ToolParam(description = "Time in ISO-8601 format") String time) {
        LocalDateTime alarmTime = LocalDateTime.parse(time, DateTimeFormatter.ISO_DATE_TIME);
        System.out.println("Alarm set for " + alarmTime);
    }

}
```

`@ToolParam` ì• ë…¸í…Œì´ì…˜ì„ ì‚¬ìš©í•˜ë©´ ë„êµ¬ ë§¤ê°œë³€ìˆ˜ì— ëŒ€í•œ í•µì‹¬ ì •ë³´ë¥¼ ì œê³µí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:

* `description`: ë§¤ê°œë³€ìˆ˜ì— ëŒ€í•œ ì„¤ëª…ìœ¼ë¡œ, ëª¨ë¸ì´ í•´ë‹¹ ë§¤ê°œë³€ìˆ˜ë¥¼ ì–´ë–»ê²Œ ì‚¬ìš©í•´ì•¼ í•˜ëŠ”ì§€ ë” ì˜ ì´í•´í•˜ëŠ” ë° ë„ì›€ì„ ì¤ë‹ˆë‹¤.  
  ì˜ˆë¥¼ ë“¤ì–´, ë§¤ê°œë³€ìˆ˜ê°€ ì–´ë–¤ í˜•ì‹ì´ì–´ì•¼ í•˜ëŠ”ì§€, ì–´ë–¤ ê°’ë“¤ì´ í—ˆìš©ë˜ëŠ”ì§€ ë“±ì„ ëª…ì‹œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

* `required`: í•´ë‹¹ ë§¤ê°œë³€ìˆ˜ê°€ í•„ìˆ˜ì¸ì§€ ì„ íƒì‚¬í•­ì¸ì§€ ì—¬ë¶€ë¥¼ ì§€ì •í•©ë‹ˆë‹¤.  
  ê¸°ë³¸ì ìœ¼ë¡œëŠ” **ëª¨ë“  ë§¤ê°œë³€ìˆ˜ëŠ” í•„ìˆ˜(required)**ë¡œ ê°„ì£¼ë©ë‹ˆë‹¤.

ë§Œì•½ ë§¤ê°œë³€ìˆ˜ê°€ `@Nullable`ë¡œ ì• ë…¸í…Œì´ì…˜ë˜ì–´ ìˆë‹¤ë©´,  
`@ToolParam`ì—ì„œ ëª…ì‹œì ìœ¼ë¡œ `required = true`ë¡œ ì„¤ì •í•˜ì§€ ì•ŠëŠ” í•œ ì„ íƒ ì‚¬í•­ìœ¼ë¡œ ê°„ì£¼ë©ë‹ˆë‹¤.

`@ToolParam` ì• ë…¸í…Œì´ì…˜ ì™¸ì—ë„, Swaggerì˜ `@Schema` ì• ë…¸í…Œì´ì…˜ì´ë‚˜ Jacksonì˜ `@JsonProperty` ì• ë…¸í…Œì´ì…˜ì„ ì‚¬ìš©í•  ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤.  
ìì„¸í•œ ë‚´ìš©ì€ [JSON Schema](#json-schema) í•­ëª©ì„ ì°¸ê³ í•˜ì„¸ìš”.

#### `ChatClient`ì— ë„êµ¬ ì¶”ê°€í•˜ê¸°

ì„ ì–¸ì  ë°©ì‹(declarative specification approach)ì„ ì‚¬ìš©í•  ê²½ìš°,  
`ChatClient`ë¥¼ í˜¸ì¶œí•  ë•Œ `tools()` ë©”ì„œë“œì— ë„êµ¬ í´ë˜ìŠ¤ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ì „ë‹¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.  
ì´ ë°©ì‹ìœ¼ë¡œ ì „ë‹¬ëœ ë„êµ¬ë“¤ì€ í•´ë‹¹ ì±„íŒ… ìš”ì²­ì—ë§Œ ìœ íš¨í•˜ê²Œ ì ìš©ë©ë‹ˆë‹¤.


```java
ChatClient.create(chatModel)
    .prompt("What day is tomorrow?")
    .tools(new DateTimeTools())
    .call()
    .content();
```

ë‚´ë¶€ì ìœ¼ë¡œ `ChatClient`ëŠ” ë„êµ¬ í´ë˜ìŠ¤ ì¸ìŠ¤í„´ìŠ¤ ë‚´ì˜ ê° `@Tool` ì• ë…¸í…Œì´ì…˜ì´ ì§€ì •ëœ ë©”ì„œë“œë¡œë¶€í„°  
`ToolCallback`ì„ ìƒì„±í•˜ê³  ì´ë¥¼ ëª¨ë¸ì— ì „ë‹¬í•©ë‹ˆë‹¤.  

ì§ì ‘ `ToolCallback`ì„ ìƒì„±í•˜ê³  ì‹¶ë‹¤ë©´, `ToolCallbacks` ìœ í‹¸ë¦¬í‹° í´ë˜ìŠ¤ë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.


```java
ToolCallback[] dateTimeTools = ToolCallbacks.from(new DateTimeTools());
```

#### ê¸°ë³¸ ë„êµ¬ë¥¼ `ChatClient`ì— ì¶”ê°€í•˜ê¸°

ì„ ì–¸ì  ë°©ì‹(declarative specification approach)ì„ ì‚¬ìš©í•  ê²½ìš°,  
ë„êµ¬ í´ë˜ìŠ¤ ì¸ìŠ¤í„´ìŠ¤ë¥¼ `defaultTools()` ë©”ì„œë“œì— ì „ë‹¬í•˜ì—¬  
`ChatClient.Builder`ì— ê¸°ë³¸ ë„êµ¬(default tools)ë¥¼ ì¶”ê°€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.  

ê¸°ë³¸ ë„êµ¬ì™€ ëŸ°íƒ€ì„ ë„êµ¬ê°€ ëª¨ë‘ ì œê³µë˜ëŠ” ê²½ìš°,  
**ëŸ°íƒ€ì„ ë„êµ¬ê°€ ê¸°ë³¸ ë„êµ¬ë¥¼ ì™„ì „íˆ ë®ì–´ì”Œìš°ê²Œ ë©ë‹ˆë‹¤.**

**âš ï¸ ê²½ê³ **  
ê¸°ë³¸ ë„êµ¬ëŠ” ë™ì¼í•œ `ChatClient.Builder`ë¡œ ìƒì„±ëœ **ëª¨ë“  `ChatClient` ì¸ìŠ¤í„´ìŠ¤ì—ì„œ ìˆ˜í–‰ë˜ëŠ” ëª¨ë“  ì±„íŒ… ìš”ì²­ì— ê³µìœ **ë©ë‹ˆë‹¤.  
ì—¬ëŸ¬ ì±„íŒ… ìš”ì²­ì—ì„œ ê³µí†µìœ¼ë¡œ ì‚¬ìš©ë˜ëŠ” ë„êµ¬ì—ëŠ” ìœ ìš©í•˜ì§€ë§Œ,  
**ì£¼ì˜í•´ì„œ ì‚¬ìš©í•˜ì§€ ì•Šìœ¼ë©´ ì›ì¹˜ ì•ŠëŠ” ìƒí™©ì—ì„œ ë„êµ¬ê°€ ë…¸ì¶œë  ìˆ˜ ìˆëŠ” ìœ„í—˜**ì´ ìˆìŠµë‹ˆë‹¤.


```java
ChatModel chatModel = ...
ChatClient chatClient = ChatClient.builder(chatModel)
    .defaultTools(new DateTimeTools())
    .build();
```

#### `ChatModel`ì— ë„êµ¬ ì¶”ê°€í•˜ê¸°

ì„ ì–¸ì  ë°©ì‹(declarative specification approach)ì„ ì‚¬ìš©í•  ê²½ìš°,  
`ChatModel`ì„ í˜¸ì¶œí•  ë•Œ ì‚¬ìš©í•˜ëŠ” `ToolCallingChatOptions`ì˜ `toolCallbacks()` ë©”ì„œë“œì—  
ë„êµ¬ í´ë˜ìŠ¤ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ì „ë‹¬í•˜ì—¬ ë„êµ¬ë¥¼ ì¶”ê°€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.  

ì´ ë°©ì‹ìœ¼ë¡œ ì¶”ê°€ëœ ë„êµ¬ë“¤ì€ **í•´ë‹¹ ì±„íŒ… ìš”ì²­ì—ë§Œ ìœ íš¨**í•©ë‹ˆë‹¤.

```java
ChatModel chatModel = ...
ToolCallback[] dateTimeTools = ToolCallbacks.from(new DateTimeTools());
ChatOptions chatOptions = ToolCallingChatOptions.builder()
    .toolCallbacks(dateTimeTools)
    .build();
Prompt prompt = new Prompt("What day is tomorrow?", chatOptions);
chatModel.call(prompt);
```

#### `ChatModel`ì— ê¸°ë³¸ ë„êµ¬ ì¶”ê°€í•˜ê¸°

ì„ ì–¸ì  ë°©ì‹(declarative specification approach)ì„ ì‚¬ìš©í•  ê²½ìš°,  
`ChatModel`ì„ ìƒì„±í•  ë•Œ ì‚¬ìš©ëœ `ToolCallingChatOptions` ì¸ìŠ¤í„´ìŠ¤ì˜ `toolCallbacks()` ë©”ì„œë“œì—  
ë„êµ¬ í´ë˜ìŠ¤ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ì „ë‹¬í•˜ì—¬ ê¸°ë³¸ ë„êµ¬ë¥¼ ì¶”ê°€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.  

ê¸°ë³¸ ë„êµ¬ì™€ ëŸ°íƒ€ì„ ë„êµ¬ê°€ ëª¨ë‘ ì œê³µë˜ë©´,  
**ëŸ°íƒ€ì„ ë„êµ¬ê°€ ê¸°ë³¸ ë„êµ¬ë¥¼ ì™„ì „íˆ ë®ì–´ì”Œì›ë‹ˆë‹¤.**

**âš ï¸ ê²½ê³ **  
ê¸°ë³¸ ë„êµ¬ëŠ” í•´ë‹¹ `ChatModel` ì¸ìŠ¤í„´ìŠ¤ì—ì„œ ìˆ˜í–‰ë˜ëŠ” **ëª¨ë“  ì±„íŒ… ìš”ì²­ì— ê³µìœ **ë©ë‹ˆë‹¤.  
ì—¬ëŸ¬ ì±„íŒ… ìš”ì²­ì—ì„œ ê³µí†µìœ¼ë¡œ ì‚¬ìš©ë˜ëŠ” ë„êµ¬ì—ëŠ” ìœ ìš©í•˜ì§€ë§Œ,  
**ì£¼ì˜í•´ì„œ ì‚¬ìš©í•˜ì§€ ì•Šìœ¼ë©´ ì›ì¹˜ ì•ŠëŠ” ìš”ì²­ì—ì„œ ë„êµ¬ê°€ ë…¸ì¶œë  ìˆ˜ ìˆëŠ” ìœ„í—˜**ì´ ìˆìŠµë‹ˆë‹¤.


```java
ToolCallback[] dateTimeTools = ToolCallbacks.from(new DateTimeTools());
ChatModel chatModel = OllamaChatModel.builder()
    .ollamaApi(OllamaApi.builder().build())
    .defaultOptions(ToolCallingChatOptions.builder()
            .toolCallbacks(dateTimeTools)
            .build())
    .build();
```

### í”„ë¡œê·¸ë˜ë° ë°©ì‹ ì§€ì •: `MethodToolCallback`

ë©”ì„œë“œë¥¼ ë„êµ¬ë¡œ ë³€í™˜í•˜ë ¤ë©´ `MethodToolCallback`ì„ í”„ë¡œê·¸ë˜ë° ë°©ì‹ìœ¼ë¡œ ìƒì„±í•˜ë©´ ë©ë‹ˆë‹¤.


```java
class DateTimeTools {

    String getCurrentDateTime() {
        return LocalDateTime.now().atZone(LocaleContextHolder.getTimeZone().toZoneId()).toString();
    }

}
```

`MethodToolCallback.Builder`ë¥¼ ì‚¬ìš©í•˜ë©´ `MethodToolCallback` ì¸ìŠ¤í„´ìŠ¤ë¥¼ ìƒì„±í•˜ë©´ì„œ  
ë„êµ¬ì— ëŒ€í•œ í•µì‹¬ ì •ë³´ë¥¼ ì§€ì •í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:

* `toolDefinition`: ë„êµ¬ì˜ ì´ë¦„, ì„¤ëª…, ì…ë ¥ ìŠ¤í‚¤ë§ˆë¥¼ ì •ì˜í•˜ëŠ” `ToolDefinition` ì¸ìŠ¤í„´ìŠ¤ì…ë‹ˆë‹¤.  
  `ToolDefinition.Builder` í´ë˜ìŠ¤ë¥¼ ì‚¬ìš©í•˜ì—¬ ìƒì„±í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. **í•„ìˆ˜ í•­ëª©ì…ë‹ˆë‹¤.**

* `toolMetadata`: ë„êµ¬ì˜ ê²°ê³¼ë¥¼ í´ë¼ì´ì–¸íŠ¸ì— ì§ì ‘ ë°˜í™˜í• ì§€ ì—¬ë¶€, ì‚¬ìš©í•  ê²°ê³¼ ë³€í™˜ê¸° ë“±  
  ì¶”ê°€ ì„¤ì •ì„ ì •ì˜í•˜ëŠ” `ToolMetadata` ì¸ìŠ¤í„´ìŠ¤ì…ë‹ˆë‹¤.  
  `ToolMetadata.Builder` í´ë˜ìŠ¤ë¥¼ ì‚¬ìš©í•˜ì—¬ ìƒì„±í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

* `toolMethod`: ë„êµ¬ë¡œ ì‚¬ìš©í•  ë©”ì„œë“œë¥¼ ë‚˜íƒ€ë‚´ëŠ” `Method` ì¸ìŠ¤í„´ìŠ¤ì…ë‹ˆë‹¤. **í•„ìˆ˜ í•­ëª©ì…ë‹ˆë‹¤.**

* `toolObject`: ë„êµ¬ ë©”ì„œë“œë¥¼ í¬í•¨í•˜ëŠ” ê°ì²´ ì¸ìŠ¤í„´ìŠ¤ì…ë‹ˆë‹¤.  
  ë©”ì„œë“œê°€ `static`ì´ë¼ë©´ ì´ íŒŒë¼ë¯¸í„°ëŠ” ìƒëµ ê°€ëŠ¥í•©ë‹ˆë‹¤.

* `toolCallResultConverter`: ë„êµ¬ í˜¸ì¶œ ê²°ê³¼ë¥¼ `String` ê°ì²´ë¡œ ë³€í™˜í•˜ì—¬  
  AI ëª¨ë¸ì— ë‹¤ì‹œ ì „ë‹¬í•˜ê¸° ìœ„í•œ `ToolCallResultConverter` ì¸ìŠ¤í„´ìŠ¤ì…ë‹ˆë‹¤.  
  ìƒëµí•˜ë©´ ê¸°ë³¸ ë³€í™˜ê¸°(`DefaultToolCallResultConverter`)ê°€ ì‚¬ìš©ë©ë‹ˆë‹¤.

---

`ToolDefinition.Builder`ëŠ” `ToolDefinition` ì¸ìŠ¤í„´ìŠ¤ë¥¼ ìƒì„±í•˜ê³ ,  
ë„êµ¬ì˜ ì´ë¦„, ì„¤ëª…, ì…ë ¥ ìŠ¤í‚¤ë§ˆë¥¼ ì •ì˜í•  ìˆ˜ ìˆë„ë¡ í•©ë‹ˆë‹¤:

* `name`: ë„êµ¬ì˜ ì´ë¦„ì…ë‹ˆë‹¤. ì§€ì •í•˜ì§€ ì•Šìœ¼ë©´ ë©”ì„œë“œ ì´ë¦„ì´ ì‚¬ìš©ë©ë‹ˆë‹¤.  
  AI ëª¨ë¸ì€ ì´ ì´ë¦„ì„ í†µí•´ ë„êµ¬ë¥¼ ì‹ë³„í•˜ë¯€ë¡œ, ë™ì¼í•œ í´ë˜ìŠ¤ ë‚´ì— ê°™ì€ ì´ë¦„ì„ ê°€ì§„ ë„êµ¬ê°€ ì¡´ì¬í•´ì„œëŠ” ì•ˆ ë©ë‹ˆë‹¤.  
  íŠ¹ì • ì±„íŒ… ìš”ì²­ì—ì„œ ëª¨ë¸ì´ ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” ëª¨ë“  ë„êµ¬ ì¤‘ì—ì„œë„ ì´ë¦„ì€ ê³ ìœ í•´ì•¼ í•©ë‹ˆë‹¤.

* `description`: ë„êµ¬ì— ëŒ€í•œ ì„¤ëª…ìœ¼ë¡œ, ëª¨ë¸ì´ ë„êµ¬ë¥¼ ì–¸ì œ, ì–´ë–»ê²Œ í˜¸ì¶œí•´ì•¼ í•˜ëŠ”ì§€ë¥¼ ì´í•´í•˜ëŠ” ë° ë„ì›€ì„ ì¤ë‹ˆë‹¤.  
  ì§€ì •í•˜ì§€ ì•Šìœ¼ë©´ ë©”ì„œë“œ ì´ë¦„ì´ ì„¤ëª…ìœ¼ë¡œ ì‚¬ìš©ë©ë‹ˆë‹¤.  
  í•˜ì§€ë§Œ **ë„êµ¬ì˜ ëª©ì ê³¼ ì‚¬ìš©ë²•ì„ ëª¨ë¸ì´ ëª…í™•íˆ ì´í•´í•˜ë„ë¡ í•˜ê¸° ìœ„í•´ì„œëŠ” ìƒì„¸í•œ ì„¤ëª…ì„ ì œê³µí•˜ëŠ” ê²ƒì´ ë§¤ìš° ì¤‘ìš”**í•©ë‹ˆë‹¤.  
  ì„¤ëª…ì´ ë¶€ì¡±í•˜ë©´ ëª¨ë¸ì´ **ë„êµ¬ë¥¼ ì‚¬ìš©í•˜ì§€ ì•Šê±°ë‚˜**, **ì˜ëª» ì‚¬ìš©í• ** ìˆ˜ ìˆìŠµë‹ˆë‹¤.

* `inputSchema`: ë„êµ¬ì˜ ì…ë ¥ ë§¤ê°œë³€ìˆ˜ì— ëŒ€í•œ JSON ìŠ¤í‚¤ë§ˆì…ë‹ˆë‹¤.  
  ì§€ì •í•˜ì§€ ì•Šìœ¼ë©´ ë©”ì„œë“œì˜ ë§¤ê°œë³€ìˆ˜ë¥¼ ê¸°ë°˜ìœ¼ë¡œ ìë™ ìƒì„±ë©ë‹ˆë‹¤.  
  `@ToolParam` ì• ë…¸í…Œì´ì…˜ì„ ì‚¬ìš©í•˜ë©´ ì…ë ¥ ë§¤ê°œë³€ìˆ˜ì— ëŒ€í•œ ì„¤ëª…, í•„ìˆ˜ ì—¬ë¶€ ë“±ì˜ ì¶”ê°€ ì •ë³´ë¥¼ ì œê³µí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.  
  ê¸°ë³¸ì ìœ¼ë¡œ ëª¨ë“  ë§¤ê°œë³€ìˆ˜ëŠ” í•„ìˆ˜ë¡œ ê°„ì£¼ë©ë‹ˆë‹¤. ìì„¸í•œ ë‚´ìš©ì€ [JSON Schema](#json-schema)ë¥¼ ì°¸ê³ í•˜ì„¸ìš”.

---

`ToolMetadata.Builder`ëŠ” `ToolMetadata` ì¸ìŠ¤í„´ìŠ¤ë¥¼ ìƒì„±í•˜ê³   
ë„êµ¬ì— ëŒ€í•œ ì¶”ê°€ ì„¤ì •ì„ ì •ì˜í•  ìˆ˜ ìˆë„ë¡ í•©ë‹ˆë‹¤:

* `returnDirect`: ë„êµ¬ ì‹¤í–‰ ê²°ê³¼ë¥¼ í´ë¼ì´ì–¸íŠ¸ì— ì§ì ‘ ë°˜í™˜í• ì§€,  
  ì•„ë‹ˆë©´ ëª¨ë¸ì— ë‹¤ì‹œ ì „ë‹¬í• ì§€ë¥¼ ì§€ì •í•©ë‹ˆë‹¤.  
  ìì„¸í•œ ë‚´ìš©ì€ [Return Direct](#return-direct) í•­ëª©ì„ ì°¸ê³ í•˜ì„¸ìš”.


```java
Method method = ReflectionUtils.findMethod(DateTimeTools.class, "getCurrentDateTime");
ToolCallback toolCallback = MethodToolCallback.builder()
    .toolDefinition(ToolDefinition.builder(method)
            .description("Get the current date and time in the user's timezone")
            .build())
    .toolMethod(method)
    .toolObject(new DateTimeTools())
    .build();
```

ë©”ì„œë“œëŠ” `static`ì¼ ìˆ˜ë„ ìˆê³  ì¸ìŠ¤í„´ìŠ¤ ë©”ì„œë“œì¼ ìˆ˜ë„ ìˆìœ¼ë©°,  
ì ‘ê·¼ ì œì–´ìë„ `public`, `protected`, `package-private`, `private` ëª¨ë‘ ê°€ëŠ¥í•©ë‹ˆë‹¤.  
í•´ë‹¹ ë©”ì„œë“œë¥¼ í¬í•¨í•˜ëŠ” í´ë˜ìŠ¤ëŠ” ìµœìƒìœ„ í´ë˜ìŠ¤ì´ê±°ë‚˜ ì¤‘ì²© í´ë˜ìŠ¤ì¼ ìˆ˜ ìˆìœ¼ë©°,  
ì¸ìŠ¤í„´ìŠ¤ë¥¼ ìƒì„±í•˜ë ¤ëŠ” ìœ„ì¹˜ì—ì„œ ì ‘ê·¼ ê°€ëŠ¥í•˜ê¸°ë§Œ í•˜ë©´ ì ‘ê·¼ ìˆ˜ì¤€ì€ ì œí•œì´ ì—†ìŠµë‹ˆë‹¤.

**ğŸ“Œ ì°¸ê³ **  
Spring AIëŠ” í•´ë‹¹ ë©”ì„œë“œë¥¼ í¬í•¨í•˜ëŠ” í´ë˜ìŠ¤ê°€ Spring Bean(`@Component` ë“±)ì¼ ê²½ìš°,  
ë„êµ¬ ë©”ì„œë“œì— ëŒ€í•´ AOT ì»´íŒŒì¼ì„ ê¸°ë³¸ìœ¼ë¡œ ì§€ì›í•©ë‹ˆë‹¤.  
ê·¸ë ‡ì§€ ì•Šì€ ê²½ìš°ì—ëŠ” GraalVM ì»´íŒŒì¼ëŸ¬ì— í•„ìš”í•œ ì„¤ì •ì„ ë³„ë„ë¡œ ì œê³µí•´ì•¼ í•©ë‹ˆë‹¤.  
ì˜ˆ: `@RegisterReflection(memberCategories = MemberCategory.INVOKE_DECLARED_METHODS)` ì• ë…¸í…Œì´ì…˜ì„ í´ë˜ìŠ¤ì— ì§€ì •

í•´ë‹¹ ë©”ì„œë“œëŠ” **ì¸ì ì—†ì´ ì •ì˜í•  ìˆ˜ë„ ìˆê³ **,  
ê¸°ë³¸í˜•(primitives), POJO, enum, ë¦¬ìŠ¤íŠ¸, ë°°ì—´, ë§µ ë“± **ëŒ€ë¶€ë¶„ì˜ íƒ€ì…ì„ ì¸ìë¡œ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤**.  
ë°˜í™˜ íƒ€ì…ë„ `void`ë¥¼ í¬í•¨í•´ ëŒ€ë¶€ë¶„ì˜ íƒ€ì…ì„ ì§€ì›í•©ë‹ˆë‹¤.  
ë‹¨, ê°’ì„ ë°˜í™˜í•˜ëŠ” ê²½ìš°ì—ëŠ” í•´ë‹¹ ë°˜í™˜ íƒ€ì…ì´ **ì§ë ¬í™” ê°€ëŠ¥í•œ íƒ€ì…**ì´ì–´ì•¼ í•˜ë©°,  
ê²°ê³¼ëŠ” ì§ë ¬í™”ë˜ì–´ ëª¨ë¸ë¡œ ë‹¤ì‹œ ì „ì†¡ë©ë‹ˆë‹¤.

**ğŸ“Œ ì°¸ê³ **  
ì¼ë¶€ íƒ€ì…ì€ ì§€ì›ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.  
ìì„¸í•œ ë‚´ìš©ì€ [Method Tool Limitations](#method-tool-limitations)ë¥¼ ì°¸ê³ í•˜ì„¸ìš”.

ë©”ì„œë“œê°€ `static`ì¸ ê²½ìš°, `toolObject()` ë©”ì„œë“œëŠ” ìƒëµí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.  
(ì •ì  ë©”ì„œë“œëŠ” ê°ì²´ ì¸ìŠ¤í„´ìŠ¤ê°€ í•„ìš”í•˜ì§€ ì•Šê¸° ë•Œë¬¸ì…ë‹ˆë‹¤.)


```java
class DateTimeTools {

    static String getCurrentDateTime() {
        return LocalDateTime.now().atZone(LocaleContextHolder.getTimeZone().toZoneId()).toString();
    }

}
```

```java
Method method = ReflectionUtils.findMethod(DateTimeTools.class, "getCurrentDateTime");
ToolCallback toolCallback = MethodToolCallback.builder()
    .toolDefinition(ToolDefinition.builder(method)
            .description("Get the current date and time in the user's timezone")
            .build())
    .toolMethod(method)
    .build();
```

Spring AIëŠ” ë©”ì„œë“œì˜ ì…ë ¥ ë§¤ê°œë³€ìˆ˜ì— ëŒ€í•´ **JSON ìŠ¤í‚¤ë§ˆë¥¼ ìë™ìœ¼ë¡œ ìƒì„±**í•©ë‹ˆë‹¤.  
ì´ ìŠ¤í‚¤ë§ˆëŠ” ëª¨ë¸ì´ ë„êµ¬ë¥¼ ì–´ë–»ê²Œ í˜¸ì¶œí•˜ê³  ìš”ì²­ì„ ì–´ë–»ê²Œ êµ¬ì„±í• ì§€ë¥¼ ì´í•´í•˜ëŠ” ë° ì‚¬ìš©ë©ë‹ˆë‹¤.  

ì…ë ¥ ë§¤ê°œë³€ìˆ˜ì— ëŒ€í•œ ì„¤ëª…, í•„ìˆ˜ ì—¬ë¶€ ë“±ì˜ ì¶”ê°€ ì •ë³´ë¥¼ ì œê³µí•˜ë ¤ë©´  
`@ToolParam` ì• ë…¸í…Œì´ì…˜ì„ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.  
ê¸°ë³¸ì ìœ¼ë¡œ **ëª¨ë“  ì…ë ¥ ë§¤ê°œë³€ìˆ˜ëŠ” í•„ìˆ˜(required)**ë¡œ ê°„ì£¼ë©ë‹ˆë‹¤.


```java
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import org.springframework.ai.tool.annotation.ToolParam;

class DateTimeTools {

    void setAlarm(@ToolParam(description = "Time in ISO-8601 format") String time) {
        LocalDateTime alarmTime = LocalDateTime.parse(time, DateTimeFormatter.ISO_DATE_TIME);
        System.out.println("Alarm set for " + alarmTime);
    }

}
```

`@ToolParam` ì• ë…¸í…Œì´ì…˜ì„ ì‚¬ìš©í•˜ë©´ ë„êµ¬ ë§¤ê°œë³€ìˆ˜ì— ëŒ€í•œ í•µì‹¬ ì •ë³´ë¥¼ ì œê³µí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:

* `description`: ë§¤ê°œë³€ìˆ˜ì— ëŒ€í•œ ì„¤ëª…ìœ¼ë¡œ, ëª¨ë¸ì´ í•´ë‹¹ ë§¤ê°œë³€ìˆ˜ë¥¼ ì–´ë–»ê²Œ ì‚¬ìš©í•˜ëŠ”ì§€ ë” ì˜ ì´í•´í•˜ëŠ” ë° ë„ì›€ì´ ë©ë‹ˆë‹¤.  
  ì˜ˆë¥¼ ë“¤ì–´, ë§¤ê°œë³€ìˆ˜ê°€ ì–´ë–¤ í˜•ì‹ì´ì–´ì•¼ í•˜ëŠ”ì§€, ì–´ë–¤ ê°’ë“¤ì´ í—ˆìš©ë˜ëŠ”ì§€ ë“±ì„ ëª…ì‹œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

* `required`: í•´ë‹¹ ë§¤ê°œë³€ìˆ˜ê°€ í•„ìˆ˜ì¸ì§€, ì„ íƒ ì‚¬í•­ì¸ì§€ ì—¬ë¶€ë¥¼ ì§€ì •í•©ë‹ˆë‹¤.  
  ê¸°ë³¸ì ìœ¼ë¡œ **ëª¨ë“  ë§¤ê°œë³€ìˆ˜ëŠ” í•„ìˆ˜(required)**ë¡œ ê°„ì£¼ë©ë‹ˆë‹¤.

ë§Œì•½ ë§¤ê°œë³€ìˆ˜ê°€ `@Nullable`ë¡œ ì• ë…¸í…Œì´ì…˜ë˜ì–´ ìˆë‹¤ë©´,  
`@ToolParam` ì• ë…¸í…Œì´ì…˜ì—ì„œ ëª…ì‹œì ìœ¼ë¡œ `required = true`ë¡œ ì„¤ì •í•˜ì§€ ì•ŠëŠ” í•œ  
ì„ íƒ ì‚¬í•­ìœ¼ë¡œ ê°„ì£¼ë©ë‹ˆë‹¤.

`@ToolParam` ì• ë…¸í…Œì´ì…˜ ì™¸ì—ë„ Swaggerì˜ `@Schema` ì• ë…¸í…Œì´ì…˜ì´ë‚˜  
Jacksonì˜ `@JsonProperty` ì• ë…¸í…Œì´ì…˜ì„ ì‚¬ìš©í•  ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤.  
ìì„¸í•œ ë‚´ìš©ì€ [JSON Schema](#json-schema) í•­ëª©ì„ ì°¸ê³ í•˜ì„¸ìš”.

#### `ChatClient` ë° `ChatModel`ì— ë„êµ¬ ì¶”ê°€í•˜ê¸°

í”„ë¡œê·¸ë˜ë° ë°©ì‹ì˜ ì§€ì • ë°©ë²•(programmatic specification approach)ì„ ì‚¬ìš©í•  ê²½ìš°,  
`MethodToolCallback` ì¸ìŠ¤í„´ìŠ¤ë¥¼ `ChatClient`ì˜ `tools()` ë©”ì„œë“œì— ì „ë‹¬í•˜ì—¬ ë„êµ¬ë¥¼ ì¶”ê°€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.  
ì´ ë„êµ¬ëŠ” **í•´ë‹¹ ì±„íŒ… ìš”ì²­ì—ë§Œ ìœ íš¨**í•©ë‹ˆë‹¤.


```java
ToolCallback toolCallback = ...
ChatClient.create(chatModel)
    .prompt("What day is tomorrow?")
    .tools(toolCallback)
    .call()
    .content();
```

#### `ChatClient`ì— ê¸°ë³¸ ë„êµ¬ ì¶”ê°€í•˜ê¸°

í”„ë¡œê·¸ë˜ë° ë°©ì‹ì˜ ì§€ì • ë°©ë²•(programmatic specification approach)ì„ ì‚¬ìš©í•  ê²½ìš°,  
`MethodToolCallback` ì¸ìŠ¤í„´ìŠ¤ë¥¼ `defaultTools()` ë©”ì„œë“œì— ì „ë‹¬í•˜ì—¬  
`ChatClient.Builder`ì— ê¸°ë³¸ ë„êµ¬ë¥¼ ì¶”ê°€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.  

ê¸°ë³¸ ë„êµ¬ì™€ ëŸ°íƒ€ì„ ë„êµ¬ê°€ ëª¨ë‘ ì œê³µë˜ëŠ” ê²½ìš°,  
**ëŸ°íƒ€ì„ ë„êµ¬ê°€ ê¸°ë³¸ ë„êµ¬ë¥¼ ì™„ì „íˆ ë®ì–´ì”ë‹ˆë‹¤.**

**âš ï¸ ê²½ê³ **  
ê¸°ë³¸ ë„êµ¬ëŠ” ë™ì¼í•œ `ChatClient.Builder`ë¡œ ìƒì„±ëœ  
**ëª¨ë“  `ChatClient` ì¸ìŠ¤í„´ìŠ¤ì—ì„œ ìˆ˜í–‰ë˜ëŠ” ëª¨ë“  ì±„íŒ… ìš”ì²­ì— ê³µìœ **ë©ë‹ˆë‹¤.  
ì—¬ëŸ¬ ì±„íŒ… ìš”ì²­ì—ì„œ ê³µí†µìœ¼ë¡œ ì‚¬ìš©ë˜ëŠ” ë„êµ¬ì—ëŠ” ìœ ìš©í•˜ì§€ë§Œ,  
**ì£¼ì˜í•´ì„œ ì‚¬ìš©í•˜ì§€ ì•Šìœ¼ë©´ ì›ì¹˜ ì•ŠëŠ” ìš”ì²­ì—ì„œ ë„êµ¬ê°€ ë…¸ì¶œë  ìˆ˜ ìˆëŠ” ìœ„í—˜**ì´ ìˆìŠµë‹ˆë‹¤.


```java
ChatModel chatModel = ...
ToolCallback toolCallback = ...
ChatClient chatClient = ChatClient.builder(chatModel)
    .defaultTools(toolCallback)
    .build();
```

#### `ChatModel`ì— ë„êµ¬ ì¶”ê°€í•˜ê¸°

í”„ë¡œê·¸ë˜ë° ë°©ì‹ì˜ ì§€ì • ë°©ë²•(programmatic specification approach)ì„ ì‚¬ìš©í•  ê²½ìš°,  
`ChatModel`ì„ í˜¸ì¶œí•  ë•Œ ì‚¬ìš©í•˜ëŠ” `ToolCallingChatOptions`ì˜ `toolCallbacks()` ë©”ì„œë“œì—  
`MethodToolCallback` ì¸ìŠ¤í„´ìŠ¤ë¥¼ ì „ë‹¬í•˜ì—¬ ë„êµ¬ë¥¼ ì¶”ê°€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.  

ì´ ë„êµ¬ëŠ” **í•´ë‹¹ ì±„íŒ… ìš”ì²­ì—ë§Œ ìœ íš¨**í•©ë‹ˆë‹¤.


```java
ChatModel chatModel = ...
ToolCallback toolCallback = ...
ChatOptions chatOptions = ToolCallingChatOptions.builder()
    .toolCallbacks(toolCallback)
    .build():
Prompt prompt = new Prompt("What day is tomorrow?", chatOptions);
chatModel.call(prompt);
```

#### `ChatModel`ì— ê¸°ë³¸ ë„êµ¬ ì¶”ê°€í•˜ê¸°

í”„ë¡œê·¸ë˜ë° ë°©ì‹ì˜ ì§€ì • ë°©ë²•(programmatic specification approach)ì„ ì‚¬ìš©í•  ê²½ìš°,  
`ChatModel`ì„ ìƒì„±í•  ë•Œ ì‚¬ìš©ëœ `ToolCallingChatOptions` ì¸ìŠ¤í„´ìŠ¤ì˜  
`toolCallbacks()` ë©”ì„œë“œì— `MethodToolCallback` ì¸ìŠ¤í„´ìŠ¤ë¥¼ ì „ë‹¬í•˜ì—¬  
ê¸°ë³¸ ë„êµ¬ë¥¼ ì¶”ê°€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ê¸°ë³¸ ë„êµ¬ì™€ ëŸ°íƒ€ì„ ë„êµ¬ê°€ ëª¨ë‘ ì œê³µë˜ëŠ” ê²½ìš°,  
**ëŸ°íƒ€ì„ ë„êµ¬ê°€ ê¸°ë³¸ ë„êµ¬ë¥¼ ì™„ì „íˆ ë®ì–´ì”ë‹ˆë‹¤.**

**âš ï¸ ê²½ê³ **  
ê¸°ë³¸ ë„êµ¬ëŠ” í•´ë‹¹ `ChatModel` ì¸ìŠ¤í„´ìŠ¤ì—ì„œ ìˆ˜í–‰ë˜ëŠ”  
**ëª¨ë“  ì±„íŒ… ìš”ì²­ì— ê³µìœ **ë©ë‹ˆë‹¤.  
ì—¬ëŸ¬ ìš”ì²­ì—ì„œ ê³µí†µì ìœ¼ë¡œ ì‚¬ìš©ë˜ëŠ” ë„êµ¬ì—ëŠ” ìœ ìš©í•˜ì§€ë§Œ,  
**ì£¼ì˜í•´ì„œ ì‚¬ìš©í•˜ì§€ ì•Šìœ¼ë©´ ë„êµ¬ê°€ ì›ì¹˜ ì•ŠëŠ” ìƒí™©ì—ì„œ ë…¸ì¶œë  ìˆ˜ ìˆëŠ” ìœ„í—˜**ì´ ìˆìŠµë‹ˆë‹¤.


```java
ToolCallback toolCallback = ...
ChatModel chatModel = OllamaChatModel.builder()
    .ollamaApi(OllamaApi.builder().build())
    .defaultOptions(ToolCallingChatOptions.builder()
            .toolCallbacks(toolCallback)
            .build())
    .build();
```

### ë©”ì„œë“œ ê¸°ë°˜ ë„êµ¬ì˜ ì œí•œ ì‚¬í•­ (Method Tool Limitations)

ë‹¤ìŒê³¼ ê°™ì€ íƒ€ì…ë“¤ì€ ë„êµ¬ë¡œ ì‚¬ìš©ë˜ëŠ” ë©”ì„œë“œì˜ ë§¤ê°œë³€ìˆ˜ë‚˜ ë°˜í™˜ íƒ€ì…ìœ¼ë¡œ í˜„ì¬ ì§€ì›ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤:

* `Optional`
* ë¹„ë™ê¸° íƒ€ì… (ì˜ˆ: `CompletableFuture`, `Future`)
* ë¦¬ì•¡í‹°ë¸Œ íƒ€ì… (ì˜ˆ: `Flow`, `Mono`, `Flux`)
* í•¨ìˆ˜í˜• íƒ€ì… (ì˜ˆ: `Function`, `Supplier`, `Consumer`)

í•¨ìˆ˜í˜• íƒ€ì…ì€ í•¨ìˆ˜ ê¸°ë°˜ ë„êµ¬ ì§€ì • ë°©ì‹(function-based tool specification approach)ì„ í†µí•´ ì§€ì›ë©ë‹ˆë‹¤.  
ìì„¸í•œ ë‚´ìš©ì€ [Functions as Tools](#functions-as-tools) í•­ëª©ì„ ì°¸ê³ í•˜ì„¸ìš”.

---

## í•¨ìˆ˜ë¥¼ ë„êµ¬ë¡œ ì‚¬ìš©í•˜ê¸° (Functions as Tools)

Spring AIëŠ” í•¨ìˆ˜ì—ì„œ ë„êµ¬ë¥¼ ì§€ì •í•  ìˆ˜ ìˆë„ë¡  
ì €ìˆ˜ì¤€ `FunctionToolCallback` êµ¬í˜„ì²´ë¥¼ ì‚¬ìš©í•˜ëŠ” **í”„ë¡œê·¸ë˜ë° ë°©ì‹**ì´ë‚˜  
ëŸ°íƒ€ì„ì— `@Bean`ìœ¼ë¡œ ë™ì ìœ¼ë¡œ ë“±ë¡í•˜ëŠ” **ë™ì  ë°©ì‹**ì„ ê¸°ë³¸ ì§€ì›í•©ë‹ˆë‹¤.

### í”„ë¡œê·¸ë˜ë° ë°©ì‹ ì§€ì •: `FunctionToolCallback`

`Function`, `Supplier`, `Consumer`, ë˜ëŠ” `BiFunction` ê³¼ ê°™ì€ í•¨ìˆ˜í˜• íƒ€ì…ì„  
`FunctionToolCallback`ì„ í”„ë¡œê·¸ë˜ë° ë°©ì‹ìœ¼ë¡œ ìƒì„±í•˜ì—¬ ë„êµ¬ë¡œ ë³€í™˜í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.


```java
public class WeatherService implements Function<WeatherRequest, WeatherResponse> {
    public WeatherResponse apply(WeatherRequest request) {
        return new WeatherResponse(30.0, Unit.C);
    }
}

public enum Unit { C, F }
public record WeatherRequest(String location, Unit unit) {}
public record WeatherResponse(double temp, Unit unit) {}
```

`FunctionToolCallback.Builder`ë¥¼ ì‚¬ìš©í•˜ë©´ `FunctionToolCallback` ì¸ìŠ¤í„´ìŠ¤ë¥¼ ìƒì„±í•˜ë©´ì„œ  
ë„êµ¬ì— ëŒ€í•œ í•µì‹¬ ì •ë³´ë¥¼ ì§€ì •í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:

* `name`: ë„êµ¬ì˜ ì´ë¦„ì…ë‹ˆë‹¤. AI ëª¨ë¸ì€ ì´ ì´ë¦„ì„ ì‚¬ìš©í•˜ì—¬ ë„êµ¬ë¥¼ ì‹ë³„í•˜ê³  í˜¸ì¶œí•©ë‹ˆë‹¤.  
  ë”°ë¼ì„œ ë™ì¼í•œ ì»¨í…ìŠ¤íŠ¸ ë‚´ì—ì„œ **ê°™ì€ ì´ë¦„ì˜ ë„êµ¬ê°€ ë‘ ê°œ ì´ìƒ ì¡´ì¬í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤**.  
  íŠ¹ì • ì±„íŒ… ìš”ì²­ì—ì„œ ëª¨ë¸ì´ ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” ëª¨ë“  ë„êµ¬ë“¤ ê°„ì— ì´ë¦„ì€ ê³ ìœ í•´ì•¼ í•©ë‹ˆë‹¤. **í•„ìˆ˜ í•­ëª©ì…ë‹ˆë‹¤.**

* `toolFunction`: ë„êµ¬ ì—­í• ì„ ìˆ˜í–‰í•  í•¨ìˆ˜í˜• ê°ì²´ì…ë‹ˆë‹¤ (`Function`, `Supplier`, `Consumer`, `BiFunction`). **í•„ìˆ˜ í•­ëª©ì…ë‹ˆë‹¤.**

* `description`: ë„êµ¬ì— ëŒ€í•œ ì„¤ëª…ìœ¼ë¡œ, ëª¨ë¸ì´ ë„êµ¬ë¥¼ **ì–¸ì œ**, **ì–´ë–»ê²Œ** í˜¸ì¶œí•´ì•¼ í•˜ëŠ”ì§€ ì´í•´í•˜ëŠ” ë° ì‚¬ìš©ë©ë‹ˆë‹¤.  
  ì§€ì •í•˜ì§€ ì•Šìœ¼ë©´ ë©”ì„œë“œ ì´ë¦„ì´ ì„¤ëª…ìœ¼ë¡œ ì‚¬ìš©ë©ë‹ˆë‹¤.  
  ê·¸ëŸ¬ë‚˜ **ë„êµ¬ì˜ ëª©ì ê³¼ ì‚¬ìš©ë²•ì„ ëª¨ë¸ì´ ëª…í™•íˆ ì´í•´í•˜ë„ë¡ í•˜ê¸° ìœ„í•´ì„œëŠ” ìƒì„¸í•œ ì„¤ëª…ì„ ì œê³µí•˜ëŠ” ê²ƒì´ ë§¤ìš° ì¤‘ìš”**í•©ë‹ˆë‹¤.  
  ì„¤ëª…ì´ ë¶€ì¡±í•˜ë©´ ëª¨ë¸ì´ **ë„êµ¬ë¥¼ ì‚¬ìš©í•˜ì§€ ì•Šê±°ë‚˜**, **ì˜ëª» ì‚¬ìš©í• ** ìˆ˜ ìˆìŠµë‹ˆë‹¤.

* `inputType`: í•¨ìˆ˜ì˜ ì…ë ¥ íƒ€ì…ì…ë‹ˆë‹¤. **í•„ìˆ˜ í•­ëª©ì…ë‹ˆë‹¤.**

* `inputSchema`: ë„êµ¬ì˜ ì…ë ¥ ë§¤ê°œë³€ìˆ˜ì— ëŒ€í•œ JSON ìŠ¤í‚¤ë§ˆì…ë‹ˆë‹¤.  
  ì§€ì •í•˜ì§€ ì•Šìœ¼ë©´ `inputType`ì„ ê¸°ì¤€ìœ¼ë¡œ ìë™ ìƒì„±ë©ë‹ˆë‹¤.  
  `@ToolParam` ì• ë…¸í…Œì´ì…˜ì„ ì‚¬ìš©í•˜ë©´ ì…ë ¥ ë§¤ê°œë³€ìˆ˜ì— ëŒ€í•œ ì„¤ëª…, í•„ìˆ˜ ì—¬ë¶€ ë“±ì˜ ì¶”ê°€ ì •ë³´ë¥¼ ì œê³µí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.  
  ê¸°ë³¸ì ìœ¼ë¡œ ëª¨ë“  ë§¤ê°œë³€ìˆ˜ëŠ” **í•„ìˆ˜(required)**ë¡œ ê°„ì£¼ë©ë‹ˆë‹¤.  
  ìì„¸í•œ ë‚´ìš©ì€ [JSON Schema](#json-schema) í•­ëª©ì„ ì°¸ê³ í•˜ì„¸ìš”.

* `toolMetadata`: ë„êµ¬ì˜ ì‹¤í–‰ ê²°ê³¼ë¥¼ í´ë¼ì´ì–¸íŠ¸ì— ì§ì ‘ ë°˜í™˜í• ì§€ ì—¬ë¶€,  
  ì‚¬ìš©í•  ê²°ê³¼ ë³€í™˜ê¸° ë“± ì¶”ê°€ ì„¤ì •ì„ ì •ì˜í•˜ëŠ” `ToolMetadata` ì¸ìŠ¤í„´ìŠ¤ì…ë‹ˆë‹¤.  
  `ToolMetadata.Builder` í´ë˜ìŠ¤ë¥¼ ì‚¬ìš©í•˜ì—¬ ìƒì„±í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

* `toolCallResultConverter`: ë„êµ¬ í˜¸ì¶œ ê²°ê³¼ë¥¼ `String` ê°ì²´ë¡œ ë³€í™˜í•˜ì—¬  
  AI ëª¨ë¸ì— ë‹¤ì‹œ ì „ë‹¬í•˜ê¸° ìœ„í•œ `ToolCallResultConverter` ì¸ìŠ¤í„´ìŠ¤ì…ë‹ˆë‹¤.  
  ìƒëµí•˜ë©´ ê¸°ë³¸ ë³€í™˜ê¸°(`DefaultToolCallResultConverter`)ê°€ ì‚¬ìš©ë©ë‹ˆë‹¤.

---

`ToolMetadata.Builder`ë¥¼ ì‚¬ìš©í•˜ë©´ `ToolMetadata` ì¸ìŠ¤í„´ìŠ¤ë¥¼ ìƒì„±í•˜ê³   
ë„êµ¬ì— ëŒ€í•œ ì¶”ê°€ ì„¤ì •ì„ ì •ì˜í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:

* `returnDirect`: ë„êµ¬ ì‹¤í–‰ ê²°ê³¼ë¥¼ í´ë¼ì´ì–¸íŠ¸ì— ì§ì ‘ ë°˜í™˜í• ì§€,  
  ì•„ë‹ˆë©´ ëª¨ë¸ì— ë‹¤ì‹œ ì „ë‹¬í• ì§€ë¥¼ ì§€ì •í•©ë‹ˆë‹¤.  
  ìì„¸í•œ ë‚´ìš©ì€ [Return Direct](#return-direct) í•­ëª©ì„ ì°¸ê³ í•˜ì„¸ìš”.


```java
ToolCallback toolCallback = FunctionToolCallback
    .builder("currentWeather", new WeatherService())
    .description("Get the weather in location")
    .inputType(WeatherRequest.class)
    .build();
```

í•¨ìˆ˜ì˜ ì…ë ¥ê°’ê³¼ ì¶œë ¥ê°’ì€ `Void` ë˜ëŠ” POJOì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.  
ì…ë ¥ ë° ì¶œë ¥ POJOëŠ” **ì§ë ¬í™” ê°€ëŠ¥**í•´ì•¼ í•˜ë©°, ê²°ê³¼ëŠ” ì§ë ¬í™”ë˜ì–´ ëª¨ë¸ë¡œ ë‹¤ì‹œ ì „ì†¡ë©ë‹ˆë‹¤.  
ë˜í•œ í•¨ìˆ˜ ìì²´ì™€ ì…ë ¥/ì¶œë ¥ íƒ€ì…ì€ ëª¨ë‘ **`public` ì ‘ê·¼ ì œì–´ì**ë¥¼ ê°€ì ¸ì•¼ í•©ë‹ˆë‹¤.

**ğŸ“Œ ì°¸ê³ **  
ì¼ë¶€ íƒ€ì…ì€ ì§€ì›ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ìì„¸í•œ ë‚´ìš©ì€ [Function Tool Limitations](#function-tool-limitations)ë¥¼ ì°¸ê³ í•˜ì„¸ìš”.

#### `ChatClient`ì— ë„êµ¬ ì¶”ê°€í•˜ê¸°

í”„ë¡œê·¸ë˜ë° ë°©ì‹ì˜ ì§€ì • ë°©ë²•(programmatic specification approach)ì„ ì‚¬ìš©í•  ê²½ìš°,  
`FunctionToolCallback` ì¸ìŠ¤í„´ìŠ¤ë¥¼ `ChatClient`ì˜ `tools()` ë©”ì„œë“œì— ì „ë‹¬í•˜ì—¬ ë„êµ¬ë¥¼ ì¶”ê°€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.  
ì´ ë„êµ¬ëŠ” **í•´ë‹¹ ì±„íŒ… ìš”ì²­ì—ë§Œ ìœ íš¨**í•©ë‹ˆë‹¤.


```java
ToolCallback toolCallback = ...
ChatClient.create(chatModel)
    .prompt("What's the weather like in Copenhagen?")
    .tools(toolCallback)
    .call()
    .content();
```

#### `ChatClient`ì— ê¸°ë³¸ ë„êµ¬ ì¶”ê°€í•˜ê¸°

í”„ë¡œê·¸ë˜ë° ë°©ì‹ì˜ ì§€ì • ë°©ë²•(programmatic specification approach)ì„ ì‚¬ìš©í•  ê²½ìš°,  
`FunctionToolCallback` ì¸ìŠ¤í„´ìŠ¤ë¥¼ `defaultTools()` ë©”ì„œë“œì— ì „ë‹¬í•˜ì—¬  
`ChatClient.Builder`ì— ê¸°ë³¸ ë„êµ¬ë¥¼ ì¶”ê°€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ê¸°ë³¸ ë„êµ¬ì™€ ëŸ°íƒ€ì„ ë„êµ¬ê°€ ëª¨ë‘ ì œê³µë˜ëŠ” ê²½ìš°,  
**ëŸ°íƒ€ì„ ë„êµ¬ê°€ ê¸°ë³¸ ë„êµ¬ë¥¼ ì™„ì „íˆ ë®ì–´ì”ë‹ˆë‹¤.**

**âš ï¸ ê²½ê³ **  
ê¸°ë³¸ ë„êµ¬ëŠ” ë™ì¼í•œ `ChatClient.Builder`ë¡œ ìƒì„±ëœ  
**ëª¨ë“  `ChatClient` ì¸ìŠ¤í„´ìŠ¤ì—ì„œ ìˆ˜í–‰ë˜ëŠ” ëª¨ë“  ì±„íŒ… ìš”ì²­ì— ê³µìœ **ë©ë‹ˆë‹¤.  
ì—¬ëŸ¬ ì±„íŒ… ìš”ì²­ì—ì„œ ê³µí†µìœ¼ë¡œ ì‚¬ìš©ë˜ëŠ” ë„êµ¬ì—ëŠ” ìœ ìš©í•˜ì§€ë§Œ,  
**ì£¼ì˜í•´ì„œ ì‚¬ìš©í•˜ì§€ ì•Šìœ¼ë©´ ë„êµ¬ê°€ ì›ì¹˜ ì•ŠëŠ” ìƒí™©ì—ì„œ ë…¸ì¶œë  ìˆ˜ ìˆëŠ” ìœ„í—˜**ì´ ìˆìŠµë‹ˆë‹¤.


```java
ChatModel chatModel = ...
ToolCallback toolCallback = ...
ChatClient chatClient = ChatClient.builder(chatModel)
    .defaultTools(toolCallback)
    .build();
```

#### `ChatModel`ì— ë„êµ¬ ì¶”ê°€í•˜ê¸°

í”„ë¡œê·¸ë˜ë° ë°©ì‹ì˜ ì§€ì • ë°©ë²•(programmatic specification approach)ì„ ì‚¬ìš©í•  ê²½ìš°,  
`FunctionToolCallback` ì¸ìŠ¤í„´ìŠ¤ë¥¼ `ToolCallingChatOptions`ì˜ `toolCallbacks()` ë©”ì„œë“œì— ì „ë‹¬í•˜ì—¬  
ë„êµ¬ë¥¼ ì¶”ê°€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.  

ì´ ë„êµ¬ëŠ” **í•´ë‹¹ ì±„íŒ… ìš”ì²­ì—ë§Œ ìœ íš¨**í•©ë‹ˆë‹¤.


```java
ChatModel chatModel = ...
ToolCallback toolCallback = ...
ChatOptions chatOptions = ToolCallingChatOptions.builder()
    .toolCallbacks(toolCallback)
    .build():
Prompt prompt = new Prompt("What's the weather like in Copenhagen?", chatOptions);
chatModel.call(prompt);
```

#### `ChatModel`ì— ê¸°ë³¸ ë„êµ¬ ì¶”ê°€í•˜ê¸°

í”„ë¡œê·¸ë˜ë° ë°©ì‹ì˜ ì§€ì • ë°©ë²•(programmatic specification approach)ì„ ì‚¬ìš©í•  ê²½ìš°,  
`ChatModel`ì„ ìƒì„±í•  ë•Œ ì‚¬ìš©ëœ `ToolCallingChatOptions` ì¸ìŠ¤í„´ìŠ¤ì˜  
`toolCallbacks()` ë©”ì„œë“œì— `FunctionToolCallback` ì¸ìŠ¤í„´ìŠ¤ë¥¼ ì „ë‹¬í•˜ì—¬  
ê¸°ë³¸ ë„êµ¬ë¥¼ ì¶”ê°€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ê¸°ë³¸ ë„êµ¬ì™€ ëŸ°íƒ€ì„ ë„êµ¬ê°€ ëª¨ë‘ ì œê³µë˜ëŠ” ê²½ìš°,  
**ëŸ°íƒ€ì„ ë„êµ¬ê°€ ê¸°ë³¸ ë„êµ¬ë¥¼ ì™„ì „íˆ ë®ì–´ì”ë‹ˆë‹¤.**

**âš ï¸ ê²½ê³ **  
ê¸°ë³¸ ë„êµ¬ëŠ” í•´ë‹¹ `ChatModel` ì¸ìŠ¤í„´ìŠ¤ì—ì„œ ìˆ˜í–‰ë˜ëŠ”  
**ëª¨ë“  ì±„íŒ… ìš”ì²­ì— ê³µìœ **ë©ë‹ˆë‹¤.  
ì—¬ëŸ¬ ìš”ì²­ì—ì„œ ê³µí†µìœ¼ë¡œ ì‚¬ìš©ë˜ëŠ” ë„êµ¬ì—ëŠ” ìœ ìš©í•˜ì§€ë§Œ,  
**ì£¼ì˜í•˜ì§€ ì•Šìœ¼ë©´ ì›ì¹˜ ì•ŠëŠ” ìš”ì²­ì—ì„œ ë„êµ¬ê°€ ë…¸ì¶œë  ìˆ˜ ìˆëŠ” ìœ„í—˜**ì´ ìˆìŠµë‹ˆë‹¤.


```java
ToolCallback toolCallback = ...
ChatModel chatModel = OllamaChatModel.builder()
    .ollamaApi(OllamaApi.builder().build())
    .defaultOptions(ToolCallingChatOptions.builder()
            .toolCallbacks(toolCallback)
            .build())
    .build();
```

### ë™ì  ì§€ì • ë°©ì‹: `@Bean`

ë„êµ¬ë¥¼ í”„ë¡œê·¸ë˜ë° ë°©ì‹ìœ¼ë¡œ ì§€ì •í•˜ëŠ” ëŒ€ì‹ ,  
ë„êµ¬ë¥¼ **Spring Beanìœ¼ë¡œ ì •ì˜**í•˜ê³   
Spring AIê°€ ëŸ°íƒ€ì„ì— `ToolCallbackResolver` ì¸í„°í˜ì´ìŠ¤  
(êµ¬í˜„ì²´: `SpringBeanToolCallbackResolver`)ë¥¼ í†µí•´ **ë™ì ìœ¼ë¡œ í•´ì„í•˜ë„ë¡** í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ì´ ë°©ì‹ì„ ì‚¬ìš©í•˜ë©´ `Function`, `Supplier`, `Consumer`, `BiFunction` íƒ€ì…ì˜ Beanì„  
ë„êµ¬ë¡œ í™œìš©í•  ìˆ˜ ìˆê²Œ ë©ë‹ˆë‹¤.

Beanì˜ ì´ë¦„ì€ ë„êµ¬ ì´ë¦„ìœ¼ë¡œ ì‚¬ìš©ë˜ë©°,  
ë„êµ¬ì— ëŒ€í•œ ì„¤ëª…ì€ Spring Frameworkì˜ `@Description` ì• ë…¸í…Œì´ì…˜ì„ í†µí•´ ì œê³µí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.  
ì´ ì„¤ëª…ì€ ëª¨ë¸ì´ ë„êµ¬ë¥¼ **ì–¸ì œ**, **ì–´ë–»ê²Œ** í˜¸ì¶œí• ì§€ë¥¼ ì´í•´í•˜ëŠ” ë° í™œìš©ë©ë‹ˆë‹¤.  
ì„¤ëª…ì„ ì œê³µí•˜ì§€ ì•Šìœ¼ë©´ ë©”ì„œë“œ ì´ë¦„ì´ ë„êµ¬ ì„¤ëª…ìœ¼ë¡œ ì‚¬ìš©ë©ë‹ˆë‹¤.

ê·¸ëŸ¬ë‚˜ **ëª¨ë¸ì´ ë„êµ¬ì˜ ëª©ì ê³¼ ì‚¬ìš©ë²•ì„ ëª…í™•íˆ ì´í•´í•  ìˆ˜ ìˆë„ë¡,  
ìƒì„¸í•œ ì„¤ëª…ì„ ì œê³µí•˜ëŠ” ê²ƒì´ ê°•ë ¥íˆ ê¶Œì¥ë©ë‹ˆë‹¤.**  
ì„¤ëª…ì´ ë¶€ì¡±í•  ê²½ìš°, ëª¨ë¸ì´ **ë„êµ¬ë¥¼ ì ì ˆí•œ ì‹œì ì— ì‚¬ìš©í•˜ì§€ ì•Šê±°ë‚˜**,  
**ì˜ëª» ì‚¬ìš©í•˜ëŠ” ë¬¸ì œ**ê°€ ë°œìƒí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.


```java
@Configuration(proxyBeanMethods = false)
class WeatherTools {

    WeatherService weatherService = new WeatherService();

	@Bean
	@Description("Get the weather in location")
	Function<WeatherRequest, WeatherResponse> currentWeather() {
		return weatherService;
	}

}
```

**ğŸ“Œ ì°¸ê³ **  
ì¼ë¶€ íƒ€ì…ì€ ì§€ì›ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ìì„¸í•œ ë‚´ìš©ì€ [Function Tool Limitations](#function-tool-limitations)ë¥¼ ì°¸ê³ í•˜ì„¸ìš”.

ë„êµ¬ì˜ ì…ë ¥ ë§¤ê°œë³€ìˆ˜ì— ëŒ€í•œ **JSON ìŠ¤í‚¤ë§ˆëŠ” ìë™ìœ¼ë¡œ ìƒì„±**ë©ë‹ˆë‹¤.  
ì…ë ¥ ë§¤ê°œë³€ìˆ˜ì— ëŒ€í•œ ì„¤ëª…ì´ë‚˜ í•„ìˆ˜ ì—¬ë¶€ ë“±ì˜ ì¶”ê°€ ì •ë³´ë¥¼ ì œê³µí•˜ë ¤ë©´  
`@ToolParam` ì• ë…¸í…Œì´ì…˜ì„ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.  
ê¸°ë³¸ì ìœ¼ë¡œ **ëª¨ë“  ì…ë ¥ ë§¤ê°œë³€ìˆ˜ëŠ” í•„ìˆ˜(required)**ë¡œ ê°„ì£¼ë©ë‹ˆë‹¤.  
ìì„¸í•œ ë‚´ìš©ì€ [JSON Schema](#json-schema)ë¥¼ ì°¸ê³ í•˜ì„¸ìš”.


```java
record WeatherRequest(@ToolParam(description = "The name of a city or a country") String location, Unit unit) {}
```

This tool specification approach has the drawback of not guaranteeing type safety, as the tool resolution is done at runtime. To mitigate this, you can specify the tool name explicitly using the `@Bean` annotation and storing the value in a constant, so that you can use it in a chat request instead of hard-coding the tool name.

```java
@Configuration(proxyBeanMethods = false)
class WeatherTools {

    public static final String CURRENT_WEATHER_TOOL = "currentWeather";

	@Bean(CURRENT_WEATHER_TOOL)
	@Description("Get the weather in location")
	Function<WeatherRequest, WeatherResponse> currentWeather() {
		...
	}

}
```

#### Adding Tools to `ChatClient`

When using the dynamic specification approach, you can pass the tool name (i.e. the function bean name) to the `tools()` method of `ChatClient`.
The tool will only be available for the specific chat request itâ€™s added to.

```java
ChatClient.create(chatModel)
    .prompt("What's the weather like in Copenhagen?")
    .tools("currentWeather")
    .call()
    .content();
```

#### Adding Default Tools to `ChatClient`

When using the dynamic specification approach, you can add default tools to a `ChatClient.Builder` by passing the tool name to the `defaultTools()` method.
If both default and runtime tools are provided, the runtime tools will completely override the default tools.

**âš ï¸ WARNING**\
Default tools are shared across all the chat requests performed by all the `ChatClient` instances built from the same `ChatClient.Builder`. They are useful for tools that are commonly used across different chat requests, but they can also be dangerous if not used carefully, risking to make them available when they shouldnâ€™t.

```java
ChatModel chatModel = ...
ChatClient chatClient = ChatClient.builder(chatModel)
    .defaultTools("currentWeather")
    .build();
```

#### Adding Tools to `ChatModel`

When using the dynamic specification approach, you can pass the tool name to the `toolNames()` method of the `ToolCallingChatOptions` you use to call the `ChatModel`. The tool will only be available for the specific chat request itâ€™s added to.

```java
ChatModel chatModel = ...
ChatOptions chatOptions = ToolCallingChatOptions.builder()
    .toolNames("currentWeather")
    .build():
Prompt prompt = new Prompt("What's the weather like in Copenhagen?", chatOptions);
chatModel.call(prompt);
```

#### Adding Default Tools to `ChatModel`

When using the dynamic specification approach, you can add default tools to `ChatModel` at construction time by passing the tool name to the `toolNames()` method of the `ToolCallingChatOptions` instance used to create the `ChatModel`.
If both default and runtime tools are provided, the runtime tools will completely override the default tools.

**âš ï¸ WARNING**\
Default tools are shared across all the chat requests performed by that `ChatModel` instance. They are useful for tools that are commonly used across different chat requests, but they can also be dangerous if not used carefully, risking to make them available when they shouldnâ€™t.

```java
ChatModel chatModel = OllamaChatModel.builder()
    .ollamaApi(OllamaApi.builder().build())
    .defaultOptions(ToolCallingChatOptions.builder()
            .toolNames("currentWeather")
            .build())
    .build();
```

### Function Tool Limitations

The following types are not currently supported as input or output types for functions used as tools:

* Primitive types
* `Optional`
* Collection types (e.g. `List`, `Map`, `Array`, `Set`) 
* Asynchronous types (e.g. `CompletableFuture`, `Future`)
* Reactive types (e.g. `Flow`, `Mono`, `Flux`).

Primitive types and collections are supported using the method-based tool specification approach. See [Methods as Tools](#methods-as-tools) for more details.

## Tool Specification

In Spring AI, tools are modeled via the `ToolCallback` interface. In the previous sections, weâ€™ve seen how to define tools from methods and functions using the built-in support provided by Spring AI (see [Methods as Tools](#methods-as-tools) and [Functions as Tools](#functions-as-tools)). This section will dive deeper into the tool specification and how to customize and extend it to support more use cases.

### Tool Callback

The `ToolCallback` interface provides a way to define a tool that can be called by the AI model, including both definition and execution logic. Itâ€™s the main interface to implement when you want to define a tool from scratch. For example, you can define a `ToolCallback` from an MCP Client (using the Model Context Protocol) or a `ChatClient` (to build a modular agentic application).

The interface provides the following methods:

```java
public interface ToolCallback {

	/**
	 * Definition used by the AI model to determine when and how to call the tool.
	 */
	ToolDefinition getToolDefinition();

	/**
	 * Metadata providing additional information on how to handle the tool.
	 */
	ToolMetadata getToolMetadata();

    /**
	 * Execute tool with the given input and return the result to send back to the AI model.
	 */
	String call(String toolInput);

    /**
	 * Execute tool with the given input and context, and return the result to send back to the AI model.
	 */
	String call(String toolInput, ToolContext tooContext);

}
```

Spring AI provides built-in implementations for tool methods (`MethodToolCallback`) and tool functions (`FunctionToolCallback`).

### Tool Definition

The `ToolDefinition` interface provides the required information for the AI model to know about the availability of the tool, including the tool name, description, and input schema. Each `ToolCallback` implementation must provide a `ToolDefinition` instance to define the tool.

The interface provides the following methods:

```java
public interface ToolDefinition {

	/**
	 * The tool name. Unique within the tool set provided to a model.
	 */
	String name();

	/**
	 * The tool description, used by the AI model to determine what the tool does.
	 */
	String description();

	/**
	 * The schema of the parameters used to call the tool.
	 */
	String inputSchema();

}
```

**ğŸ“Œ NOTE**\
See [JSON Schema](#json-schema) for more details on the input schema.

The `ToolDefinition.Builder` lets you build a `ToolDefinition` instance using the default implementation (`DefaultToolDefinition`).

```java
ToolDefinition toolDefinition = ToolDefinition.builder()
    .name("currentWeather")
    .description("Get the weather in location")
    .inputSchema("""
        {
            "type": "object",
            "properties": {
                "location": {
                    "type": "string"
                },
                "unit": {
                    "type": "string",
                    "enum": ["C", "F"]
                }
            },
            "required": ["location", "unit"]
        }
    """)
    .build();
```

#### Method Tool Definition

When building tools from a method, the `ToolDefinition` is automatically generated for you. In case you prefer to generate the `ToolDefinition` yourself, you can use this convenient builder.

```java
Method method = ReflectionUtils.findMethod(DateTimeTools.class, "getCurrentDateTime");
ToolDefinition toolDefinition = ToolDefinition.from(method);
```

The `ToolDefinition` generated from a method includes the method name as the tool name, the method name as the tool description, and the JSON schema of the method input parameters. If the method is annotated with `@Tool`, the tool name and description will be taken from the annotation, if set.

**ğŸ“Œ NOTE**\
See [Methods as Tools](#methods-as-tools) for more details.

If youâ€™d rather provide some or all of the attributes explicitly, you can use the `ToolDefinition.Builder` to build a custom `ToolDefinition` instance.

```java
Method method = ReflectionUtils.findMethod(DateTimeTools.class, "getCurrentDateTime");
ToolDefinition toolDefinition = ToolDefinition.builder(method)
    .name("currentDateTime")
    .description("Get the current date and time in the user's timezone")
    .inputSchema(JsonSchemaGenerator.generateForMethodInput(method))
    .build();
```

#### Function Tool Definition

When building tools from a function, the `ToolDefinition` is automatically generated for you. When you use the `FunctionToolCallback.Builder` to build a `FunctionToolCallback` instance, you can provide the tool name, description, and input schema that will be used to generate the `ToolDefinition`. See [Functions as Tools](#functions-as-tools) for more details.

### JSON Schema

When providing a tool to the AI model, the model needs to know the schema of the input type for calling the tool. The schema is used to understand how to call the tool and prepare the tool request. Spring AI provides built-in support for generating the JSON Schema of the input type for a tool via the `JsonSchemaGenerator` class. The schema is provided as part of the `ToolDefinition`.

**ğŸ“Œ NOTE**\
See [Tool Definition](#tool-definition) for more details on the `ToolDefinition` and how to pass the input schema to it.

The `JsonSchemaGenerator` class is used under the hood to generate the JSON schema for the input parameters of a method or a function, using any of the strategies described in [Methods as Tools](#methods-as-tools) and [Functions as Tools](#functions-as-tools). The JSON schema generation logic supports a series of annotations that you can use on the input parameters for methods and functions to customize the resulting schema.

This section describes two main options you can customize when generating the JSON schema for the input parameters of a tool: description and required status.

#### Description

Besides providing a description for the tool itself, you can also provide a description for the input parameters of a tool. The description can be used to provide key information about the input parameters, such as what format the parameter should be in, what values are allowed, and so on. This is useful to help the model understand the input schema and how to use it. Spring AI provides built-in support for generating the description for an input parameter using one of the following annotations:

* `@ToolParam(description = "...")` from Spring AI
* `@JsonClassDescription(description = "...")` from Jackson
* `@JsonPropertyDescription(description = "...")` from Jackson
* `@Schema(description = "...")` from Swagger.

This approach works for both methods and functions, and you can use it recursively for nested types.

```java
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import org.springframework.ai.tool.annotation.Tool;
import org.springframework.ai.tool.annotation.ToolParam;
import org.springframework.context.i18n.LocaleContextHolder;

class DateTimeTools {

    @Tool(description = "Set a user alarm for the given time")
    void setAlarm(@ToolParam(description = "Time in ISO-8601 format") String time) {
        LocalDateTime alarmTime = LocalDateTime.parse(time, DateTimeFormatter.ISO_DATE_TIME);
        System.out.println("Alarm set for " + alarmTime);
    }

}
```

#### Required/Optional

By default, each input parameter is considered required, which forces the AI model to provide a value for it when calling the tool. However, you can make an input parameter optional by using one of the following annotations, in this order of precedence:

* `@ToolParam(required = false)` from Spring AI
* `@JsonProperty(required = false)` from Jackson
* `@Schema(required = false)` from Swagger
* `@Nullable` from Spring Framework.

This approach works for both methods and functions, and you can use it recursively for nested types.

```java
class CustomerTools {

    @Tool(description = "Update customer information")
    void updateCustomerInfo(Long id, String name, @ToolParam(required = false) String email) {
        System.out.println("Updated info for customer with id: " + id);
    }

}
```

**âš ï¸ WARNING**\
Defining the correct required status for the input parameter is crucial to mitigate the risk of hallucinations and ensure the model provides the right input when calling the tool. In the previous example, the `email` parameter is optional, which means the model can call the tool without providing a value for it. If the parameter was required, the model would have to provide a value for it when calling the tool. And if no value existed, the model would probably make one up, leading to hallucinations.

### Result Conversion

The result of a tool call is serialized using a `ToolCallResultConverter` and then sent back to the AI model. The `ToolCallResultConverter` interface provides a way to convert the result of a tool call to a `String` object.

The interface provides the following method:

```java
@FunctionalInterface
public interface ToolCallResultConverter {

	/**
	 * Given an Object returned by a tool, convert it to a String compatible with the
	 * given class type.
	 */
	String convert(@Nullable Object result, @Nullable Type returnType);

}
```

The result must be a serializable type. By default, the result is serialized to JSON using Jackson (`DefaultToolCallResultConverter`), but you can customize the serialization process by providing your own `ToolCallResultConverter` implementation.

Spring AI relies on the `ToolCallResultConverter` in both method and function tools.

#### Method Tool Call Result Conversion

When building tools from a method with the declarative approach, you can provide a custom `ToolCallResultConverter` to use for the tool by setting the `resultConverter()` attribute of the `@Tool` annotation.

```java
class CustomerTools {

    @Tool(description = "Retrieve customer information", resultConverter = CustomToolCallResultConverter.class)
    Customer getCustomerInfo(Long id) {
        return customerRepository.findById(id);
    }

}
```

If using the programmatic approach, you can provide a custom `ToolCallResultConverter` to use for the tool by setting the `resultConverter()` attribute of the `MethodToolCallback.Builder`.

See [Methods as Tools](#methods-as-tools) for more details.

#### Function Tool Call Result Conversion

When building tools from a function using the programmatic approach, you can provide a custom `ToolCallResultConverter` to use for the tool by setting the `resultConverter()` attribute of the `FunctionToolCallback.Builder`.

See [Functions as Tools](#functions-as-tools) for more details.

### Tool Context

Spring AI supports passing additional contextual information to tools through the `ToolContext` API. This feature allows you to provide extra, user-provided data that can be used within the tool execution along with the tool arguments passed by the AI model. 

![image.png](https://file-api.ksq9511.synology.me:5353/obsidian-files/image/20250520181323_image.png)


```java
class CustomerTools {

    @Tool(description = "Retrieve customer information")
    Customer getCustomerInfo(Long id, ToolContext toolContext) {
        return customerRepository.findById(id, toolContext.get("tenantId"));
    }

}
```

The `ToolContext` is populated with the data provided by the user when invoking `ChatClient`.

```java
ChatModel chatModel = ...

String response = ChatClient.create(chatModel)
        .prompt("Tell me more about the customer with ID 42")
        .tools(new CustomerTools())
        .toolContext(Map.of("tenantId", "acme"))
        .call()
        .content();

System.out.println(response);
```

**ğŸ“Œ NOTE**
None of the data provided in the `ToolContext` is sent to the AI model.

Similarly, you can define tool context data when invoking the `ChatModel` directly.

```java
ChatModel chatModel = ...
ToolCallback[] customerTools = ToolCallbacks.from(new CustomerTools());
ChatOptions chatOptions = ToolCallingChatOptions.builder()
    .toolCallbacks(customerTools)
    .toolContext(Map.of("tenantId", "acme"))
    .build();
Prompt prompt = new Prompt("Tell me more about the customer with ID 42", chatOptions);
chatModel.call(prompt);
```

If the `toolContext` option is set both in the default options and in the runtime options, the resulting `ToolContext` will be the merge of the two,
where the runtime options take precedence over the default options.

### Return Direct

By default, the result of a tool call is sent back to the model as a response. Then, the model can use the result to continue the conversation.

There are cases where youâ€™d rather return the result directly to the caller instead of sending it back to the model. For example, if you build an agent that relies on a RAG tool, you might want to return the result directly to the caller instead of sending it back to the model for unnecessary post-processing. Or perhaps you have certain tools that should end the reasoning loop of the agent.

Each `ToolCallback` implementation can define whether the result of a tool call should be returned directly to the caller or sent back to the model. By default, the result is sent back to the model. But you can change this behavior per tool.

The `ToolCallingManager`, responsible for managing the tool execution lifecycle, is in charge of handling the `returnDirect` attribute associated with the tool. If the attribute is set to `true`, the result of the tool call is returned directly to the caller. Otherwise, the result is sent back to the model.

**ğŸ“Œ NOTE**\
If multiple tool calls are requested at once, the `returnDirect` attribute must be set to `true` for all the tools to return the results directly to the caller. Otherwise, the results will be sent back to the model.

![image.png](https://file-api.ksq9511.synology.me:5353/obsidian-files/image/20250520181357_image.png)


1. When we want to make a tool available to the model, we include its definition in the chat request. If we want the result of the tool execution to be returned directly to the caller, we set the `returnDirect` attribute to `true`.
2. When the model decides to call a tool, it sends a response with the tool name and the input parameters modeled after the defined schema.
3. The application is responsible for using the tool name to identify and execute the tool with the provided input parameters.
4. The result of the tool call is processed by the application.
5. The application sends the tool call result directly to the caller, instead of sending it back to the model.

#### Method Return Direct

When building tools from a method with the declarative approach, you can mark a tool to return the result directly to the caller by setting the `returnDirect` attribute of the `@Tool` annotation to `true`.

```java
class CustomerTools {

    @Tool(description = "Retrieve customer information", returnDirect = true)
    Customer getCustomerInfo(Long id) {
        return customerRepository.findById(id);
    }

}
```

If using the programmatic approach, you can set the `returnDirect` attribute via the `ToolMetadata` interface and pass it to the `MethodToolCallback.Builder`.

```java
ToolMetadata toolMetadata = ToolMetadata.builder()
    .returnDirect(true)
    .build();
```

See [Methods as Tools](#methods-as-tools) for more details.

#### Function Return Direct

When building tools from a function with the programmatic approach, you can set the `returnDirect` attribute via the `ToolMetadata` interface and pass it to the `FunctionToolCallback.Builder`.

```java
ToolMetadata toolMetadata = ToolMetadata.builder()
    .returnDirect(true)
    .build();
```

See [Functions as Tools](#functions-as-tools) for more details.

## Tool Execution

The tool execution is the process of calling the tool with the provided input arguments and returning the result. The tool execution is handled by the `ToolCallingManager` interface, which is responsible for managing the tool execution lifecycle.

```java
public interface ToolCallingManager {

	/**
	 * Resolve the tool definitions from the model's tool calling options.
	 */
	List<ToolDefinition> resolveToolDefinitions(ToolCallingChatOptions chatOptions);

	/**
	 * Execute the tool calls requested by the model.
	 */
	ToolExecutionResult executeToolCalls(Prompt prompt, ChatResponse chatResponse);

}
```

If youâ€™re using any of the Spring AI Spring Boot Starters, `DefaultToolCallingManager` is the autoconfigured implementation of the `ToolCallingManager` interface. You can customize the tool execution behavior by providing your own `ToolCallingManager` bean.

```java
@Bean
ToolCallingManager toolCallingManager() {
    return ToolCallingManager.builder().build();
}
```

By default, Spring AI manages the tool execution lifecycle transparently for you from within each `ChatModel` implementation. But you have the possibility to opt-out of this behavior and control the tool execution yourself. This section describes these two scenarios.

### Framework-Controlled Tool Execution

When using the default behavior, Spring AI will automatically intercept any tool call request from the model, call the tool and return the result to the model. All of this is done transparently for you by each `ChatModel` implementation using a `ToolCallingManager`.

![image.png](https://file-api.ksq9511.synology.me:5353/obsidian-files/image/20250520181442_image.png)



1. When we want to make a tool available to the model, we include its definition in the chat request (`Prompt`) and invoke the `ChatModel` API which sends the request to the AI model.
2. When the model decides to call a tool, it sends a response (`ChatResponse`) with the tool name and the input parameters modeled after the defined schema.
3. The `ChatModel` sends the tool call request to the `ToolCallingManager` API.
4. The `ToolCallingManager` is responsible for identifying the tool to call and executing it with the provided input parameters.
5. The result of the tool call is returned to the `ToolCallingManager`.
6. The `ToolCallingManager` returns the tool execution result back to the `ChatModel`.
7. The `ChatModel` sends the tool execution result back to the AI model (`ToolResponseMessage`).
8. The AI model generates the final response using the tool call result as additional context and sends it back to the caller (`ChatResponse`) via the `ChatClient`.

**âš ï¸ WARNING**\
Currently, the internal messages exchanged with the model regarding the tool execution are not exposed to the user. If you need to access these messages, you should use the user-controlled tool execution approach.

The logic determining whether a tool call is eligible for execution is handled by the `ToolExecutionEligibilityPredicate` interface. By default, the tool execution eligibility is determined by checking if the `internalToolExecutionEnabled` attribute of `ToolCallingChatOptions` is set to `true` (the default value), and if the `ChatResponse` contains any tool calls.

```java
public class DefaultToolExecutionEligibilityPredicate implements ToolExecutionEligibilityPredicate {

	@Override
	public boolean test(ChatOptions promptOptions, ChatResponse chatResponse) {
		return ToolCallingChatOptions.isInternalToolExecutionEnabled(promptOptions) && chatResponse != null
				&& chatResponse.hasToolCalls();
	}

}
```

You can provide your custom implementation of `ToolExecutionEligibilityPredicate` when creating the `ChatModel` bean.

### User-Controlled Tool Execution

There are cases where youâ€™d rather control the tool execution lifecycle yourself. You can do so by setting the `internalToolExecutionEnabled` attribute of `ToolCallingChatOptions` to `false`.

When you invoke a `ChatModel` with this option, the tool execution will be delegated to the caller, giving you full control over the tool execution lifecycle. Itâ€™s your responsibility checking for tool calls in the `ChatResponse` and executing them using the `ToolCallingManager`.

The following example demonstrates a minimal implementation of the user-controlled tool execution approach:

```java
ChatModel chatModel = ...
ToolCallingManager toolCallingManager = ToolCallingManager.builder().build();

ChatOptions chatOptions = ToolCallingChatOptions.builder()
    .toolCallbacks(new CustomerTools())
    .internalToolExecutionEnabled(false)
    .build();
Prompt prompt = new Prompt("Tell me more about the customer with ID 42", chatOptions);

ChatResponse chatResponse = chatModel.call(prompt);

while (chatResponse.hasToolCalls()) {
    ToolExecutionResult toolExecutionResult = toolCallingManager.executeToolCalls(prompt, chatResponse);

    prompt = new Prompt(toolExecutionResult.conversationHistory(), chatOptions);

    chatResponse = chatModel.call(prompt);
}

System.out.println(chatResponse.getResult().getOutput().getText());
```

**ğŸ“Œ NOTE**
When choosing the user-controlled tool execution approach, we recommend using a `ToolCallingManager` to manage the tool calling operations. This way, you can benefit from the built-in support provided by Spring AI for tool execution. However, nothing prevents you from implementing your own tool execution logic.

The next examples shows a minimal implementation of the user-controlled tool execution approach combined with the usage of the `ChatMemory` API:

```java
ToolCallingManager toolCallingManager = DefaultToolCallingManager.builder().build();
ChatMemory chatMemory = MessageWindowChatMemory.builder().build();
String conversationId = UUID.randomUUID().toString();

ChatOptions chatOptions = ToolCallingChatOptions.builder()
    .toolCallbacks(ToolCallbacks.from(new MathTools()))
    .internalToolExecutionEnabled(false)
    .build();
Prompt prompt = new Prompt(
        List.of(new SystemMessage("You are a helpful assistant."), new UserMessage("What is 6 * 8?")),
        chatOptions);
chatMemory.add(conversationId, prompt.getInstructions());

Prompt promptWithMemory = new Prompt(chatMemory.get(conversationId), chatOptions);
ChatResponse chatResponse = chatModel.call(promptWithMemory);
chatMemory.add(conversationId, chatResponse.getResult().getOutput());

while (chatResponse.hasToolCalls()) {
    ToolExecutionResult toolExecutionResult = toolCallingManager.executeToolCalls(promptWithMemory,
            chatResponse);
    chatMemory.add(conversationId, toolExecutionResult.conversationHistory()
        .get(toolExecutionResult.conversationHistory().size() - 1));
    promptWithMemory = new Prompt(chatMemory.get(conversationId), chatOptions);
    chatResponse = chatModel.call(promptWithMemory);
    chatMemory.add(conversationId, chatResponse.getResult().getOutput());
}

UserMessage newUserMessage = new UserMessage("What did I ask you earlier?");
chatMemory.add(conversationId, newUserMessage);

ChatResponse newResponse = chatModel.call(new Prompt(chatMemory.get(conversationId)));
```

### Exception Handling

When a tool call fails, the exception is propagated as a `ToolExecutionException` which can be caught to handle the error. A `ToolExecutionExceptionProcessor` can be used to handle a `ToolExecutionException` with two outcomes: either producing an error message to be sent back to the AI model or throwing an exception to be handled by the caller.

```java
@FunctionalInterface
public interface ToolExecutionExceptionProcessor {

	/**
	 * Convert an exception thrown by a tool to a String that can be sent back to the AI
	 * model or throw an exception to be handled by the caller.
	 */
	String process(ToolExecutionException exception);

}
```

If youâ€™re using any of the Spring AI Spring Boot Starters, `DefaultToolExecutionExceptionProcessor` is the autoconfigured implementation of the `ToolExecutionExceptionProcessor` interface. By default, the error message is sent back to the model. The `DefaultToolExecutionExceptionProcessor` constructor lets you set the `alwaysThrow` attribute to `true` or `false`. If `true`, an exception will be thrown instead of sending an error message back to the model.

```java
@Bean
ToolExecutionExceptionProcessor toolExecutionExceptionProcessor() {
    return new DefaultToolExecutionExceptionProcessor(true);
}
```

**ğŸ“Œ NOTE**
If you defined your own `ToolCallback` implementation, make sure to throw a `ToolExecutionException` when an error occurs as part of the tool execution logic in the `call()` method.

The `ToolExecutionExceptionProcessor` is used internally by the default `ToolCallingManager` (`DefaultToolCallingManager`) to handle exceptions during tool execution. See [Tool Execution](#tool-execution) for more details about the tool execution lifecycle.

## Tool Resolution

The main approach for passing tools to a model is by providing the `ToolCallback`(s) when invoking the `ChatClient` or the `ChatModel`,
using one of the strategies described in [Methods as Tools](#methods-as-tools) and [Functions as Tools](#functions-as-tools).

However, Spring AI also supports resolving tools dynamically at runtime using the `ToolCallbackResolver` interface. 

```java
public interface ToolCallbackResolver {

	/**
	 * Resolve the {@link ToolCallback} for the given tool name.
	 */
	@Nullable
	ToolCallback resolve(String toolName);

}
```

When using this approach:

* On the client-side, you provide the tool names to the `ChatClient` or the `ChatModel` instead of the `ToolCallback`(s).
* On the server-side, a `ToolCallbackResolver` implementation is responsible for resolving the tool names to the corresponding `ToolCallback` instances.

By default, Spring AI relies on a `DelegatingToolCallbackResolver` that delegates the tool resolution to a list of `ToolCallbackResolver` instances:

* The `SpringBeanToolCallbackResolver` resolves tools from Spring beans of type `Function`, `Supplier`, `Consumer`, or `BiFunction`. See [_dynamic_specification_bean](#_dynamic_specification_bean) for more details.
* The `StaticToolCallbackResolver` resolves tools from a static list of `ToolCallback` instances. When using the Spring Boot Autoconfiguration, this resolver is automatically configured with all the beans of type `ToolCallback` defined in the application context.

If you rely on the Spring Boot Autoconfiguration, you can customize the resolution logic by providing a custom `ToolCallbackResolver` bean.

```java
@Bean
ToolCallbackResolver toolCallbackResolver(List<FunctionCallback> toolCallbacks) {
    StaticToolCallbackResolver staticToolCallbackResolver = new StaticToolCallbackResolver(toolCallbacks);
    return new DelegatingToolCallbackResolver(List.of(staticToolCallbackResolver));
}
```

The `ToolCallbackResolver` is used internally by the `ToolCallingManager` to resolve tools dynamically at runtime, supporting both [_framework_controlled_tool_execution](#_framework_controlled_tool_execution) and [_user_controlled_tool_execution](#_user_controlled_tool_execution).

## Observability

Tool calling includes observability support with spring.ai.tool observations that measure completion time and propagate tracing information. See [Tool Calling Observability](observability/index.adoc#_tool_calling).

Optionally, Spring AI can export tool call arguments and results as span attributes, disabled by default for sensitivity reasons. Details: [Tool Call Arguments and Result Data](observability/index.adoc#_tool_call_arguments_and_result_data).

### Logging

All the main operations of the tool calling features are logged at the `DEBUG` level. You can enable the logging by setting the log level to `DEBUG` for the `org.springframework.ai` package.
